// Public Domain. See "unlicense" statement at the end of this file.

//
// QUICK NOTES
//
// General
// - dr_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in dr_gui. It contains basic information about it's layout and hierarchy.
// - Elements can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify dr_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by dr_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to drgui_post_inbound_event() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let dr_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but dr_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from drgui_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   drgui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times dr_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because dr_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with drgui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with drgui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with drgui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//   - on_change_cursor: Called when the current cursor needs to be changed as a result of the mouse moving over a new element.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call drgui_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   drgui_draw() on a parent element and then again on it's children because dr_gui will do that automatically.
// - drgui_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   drgui_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. dr_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with drgui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - drgui_disable_auto_dirty()
//   - drgui_draw(pTopLevelElement, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.
//


//
// OPTIONS
//
// #define DRGUI_NO_DR_2D
//   Disable easy_draw integration. Disabling dr_2d will require you to implement your own drawing callbacks.
//


//
// EXAMPLES
//
// Basic Drawing:
//
// drgui_draw(pTopLevelElement, 0, 0, drgui_get_width(pTopLevelElement), drgui_get_height(pTopLevelElement));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(drgui_element* pElement, drgui_rect relativeRect) {
//     drgui_rect absoluteRect = relativeRect;
//     drgui_make_rect_absolute(pElement, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)drgui_get_user_data(drgui_find_top_level_element(pElement)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     drgui_element* pTopLevelElement = (drgui_element*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelElement != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     drgui_draw(pTopLevelElement, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//



#ifndef dr_gui_h
#define dr_gui_h

#ifndef DRGUI_NO_DR_2D
// If you're using easy_draw integration, set the path below to the relative location of dr_2d. By default, the
// following structure is assumed:
// <Base Directory>
//   - dr_libs
//     - dr_2d.h
//     - dr_gui.h
#include "dr_2d.h"
#endif

#include <stdbool.h>

#ifndef DRGUI_MAX_FONT_FAMILY_LENGTH
#define DRGUI_MAX_FONT_FAMILY_LENGTH  128
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef struct drgui_context drgui_context;
typedef struct drgui_element drgui_element;
typedef struct drgui_color drgui_color;
typedef struct drgui_rect drgui_rect;
typedef struct drgui_painting_callbacks drgui_painting_callbacks;
typedef struct drgui_font drgui_font;
typedef struct drgui_image drgui_image;
typedef struct drgui_font_metrics drgui_font_metrics;
typedef struct drgui_glyph_metrics drgui_glyph_metrics;

typedef unsigned char drgui_byte;
typedef unsigned int drgui_key;

typedef void* drgui_resource;

/// Common system cursors.
typedef enum
{
    drgui_cursor_none,
    drgui_cursor_default,
    drgui_cursor_arrow = drgui_cursor_default,
    drgui_cursor_text,
    drgui_cursor_cross,
    drgui_cursor_size_ns,           // North/South resize arrows.
    drgui_cursor_size_we,           // West/East resize arrows.
    drgui_cursor_size_nesw,         // North/East, South/West resize arrows.
    drgui_cursor_size_nwse          // North/West, South/East resize arrows.
} drgui_cursor_type;

/// Font weights.
typedef enum
{
    drgui_font_weight_medium,
    drgui_font_weight_thin,
    drgui_font_weight_extra_light,
    drgui_font_weight_light,
    drgui_font_weight_semi_bold,
    drgui_font_weight_bold,
    drgui_font_weight_extra_bold,
    drgui_font_weight_heavy,

    drgui_font_weight_normal  = drgui_font_weight_medium,
    drgui_font_weight_default = drgui_font_weight_medium

} drgui_font_weight;

/// Font slants.
typedef enum
{
    drgui_font_slant_none,
    drgui_font_slant_italic,
    drgui_font_slant_oblique

} drgui_font_slant;


/// Font metrics.
struct drgui_font_metrics
{
    int ascent;
    int descent;
    int lineHeight;
    int spaceWidth;
};

/// Glyph metrics.
struct drgui_glyph_metrics
{
    int width;
    int height;
    int originX;
    int originY;
    int advanceX;
    int advanceY;
};


/// Structure representing an RGBA color. Color components are specified in the range of 0 - 255.
struct drgui_color
{
    drgui_byte r;
    drgui_byte g;
    drgui_byte b;
    drgui_byte a;
};

/// Structure representing a rectangle.
struct drgui_rect
{
    float left;
    float top;
    float right;
    float bottom;
};


#define DRGUI_IMAGE_DRAW_BACKGROUND    (1 << 0)
#define DRGUI_IMAGE_DRAW_BOUNDS        (1 << 1)
#define DRGUI_IMAGE_CLIP_BOUNDS        (1 << 2)        //< Clips the image to the bounds
#define DRGUI_IMAGE_ALIGN_CENTER       (1 << 3)
#define DRGUI_IMAGE_HINT_NO_ALPHA      (1 << 4)

typedef struct
{
    /// The destination position on the x axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    drgui_color foregroundTint;

    /// The background color. Only used if the DR2D_IMAGE_DRAW_BACKGROUND option is set.
    drgui_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    drgui_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} drgui_draw_image_args;


typedef void (* drgui_callback)();

typedef void (* drgui_on_move_proc)                 (drgui_element* pElement, float newRelativePosX, float newRelativePosY);
typedef void (* drgui_on_size_proc)                 (drgui_element* pElement, float newWidth, float newHeight);
typedef void (* drgui_on_mouse_enter_proc)          (drgui_element* pElement);
typedef void (* drgui_on_mouse_leave_proc)          (drgui_element* pElement);
typedef void (* drgui_on_mouse_move_proc)           (drgui_element* pElement, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_down_proc)    (drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_up_proc)      (drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_dblclick_proc)(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_wheel_proc)          (drgui_element* pElement, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_key_down_proc)             (drgui_element* pElement, drgui_key key, int stateFlags);
typedef void (* drgui_on_key_up_proc)               (drgui_element* pElement, drgui_key key, int stateFlags);
typedef void (* drgui_on_printable_key_down_proc)   (drgui_element* pElement, unsigned int character, int stateFlags);
typedef void (* drgui_on_paint_proc)                (drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);
typedef void (* drgui_on_dirty_proc)                (drgui_element* pElement, drgui_rect relativeRect);
typedef bool (* drgui_on_hittest_proc)              (drgui_element* pElement, float relativePosX, float relativePosY);
typedef void (* drgui_on_capture_mouse_proc)        (drgui_element* pElement);
typedef void (* drgui_on_release_mouse_proc)        (drgui_element* pElement);
typedef void (* drgui_on_capture_keyboard_proc)     (drgui_element* pElement, drgui_element* pPrevCapturedElement);
typedef void (* drgui_on_release_keyboard_proc)     (drgui_element* pElement, drgui_element* pNewCapturedElement);
typedef void (* drgui_on_change_cursor_proc)        (drgui_element* pElement, drgui_cursor_type cursor);
typedef void (* drgui_on_log)                       (drgui_context* pContext, const char* message);

typedef void (* drgui_draw_begin_proc)                   (void* pPaintData);
typedef void (* drgui_draw_end_proc)                     (void* pPaintData);
typedef void (* drgui_set_clip_proc)                     (drgui_rect relativeRect, void* pPaintData);
typedef void (* drgui_get_clip_proc)                     (drgui_rect* pRectOut, void* pPaintData);
typedef void (* drgui_draw_line_proc)                    (float startX, float startY, float endX, float endY, float width, drgui_color color, void* pPaintData);
typedef void (* drgui_draw_rect_proc)                    (drgui_rect relativeRect, drgui_color color, void* pPaintData);
typedef void (* drgui_draw_rect_outline_proc)            (drgui_rect relativeRect, drgui_color color, float outlineWidth, void* pPaintData);
typedef void (* drgui_draw_rect_with_outline_proc)       (drgui_rect relativeRect, drgui_color color, float outlineWidth, drgui_color outlineColor, void* pPaintData);
typedef void (* drgui_draw_round_rect_proc)              (drgui_rect relativeRect, drgui_color color, float radius, void* pPaintData);
typedef void (* drgui_draw_round_rect_outline_proc)      (drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, void* pPaintData);
typedef void (* drgui_draw_round_rect_with_outline_proc) (drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData);
typedef void (* drgui_draw_text_proc)                    (drgui_resource font, const char* text, int textLengthInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData);
typedef void (* drgui_draw_image_proc)                   (drgui_resource image, drgui_draw_image_args* pArgs, void* pPaintData);

typedef drgui_resource (* drgui_create_font_proc)                        (void* pPaintingContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation);
typedef void           (* drgui_delete_font_proc)                        (drgui_resource font);
typedef unsigned int   (* drgui_get_font_size_proc)                      (drgui_resource font);
typedef bool           (* drgui_get_font_metrics_proc)                   (drgui_resource font, drgui_font_metrics* pMetricsOut);
typedef bool           (* drgui_get_glyph_metrics_proc)                  (drgui_resource font, unsigned int utf32, drgui_glyph_metrics* pMetricsOut);
typedef bool           (* drgui_measure_string_proc)                     (drgui_resource font, const char* text, size_t textSizeInBytes, float* pWidthOut, float* pHeightOut);
typedef bool           (* drgui_get_text_cursor_position_from_point_proc)(drgui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut);
typedef bool           (* drgui_get_text_cursor_position_from_char_proc) (drgui_resource font, const char* text, unsigned int characterIndex, float* pTextCursorPosXOut);

typedef drgui_resource (* drgui_create_image_proc)  (void* pPaintingContext, unsigned int width, unsigned int height, unsigned int stride, const void* pImageData);
typedef void           (* drgui_delete_image_proc)  (drgui_resource image);
typedef void           (* drgui_get_image_size_proc)(drgui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut);

typedef bool (* drgui_visible_iteration_proc)(drgui_element* pElement, drgui_rect *pRelativeRect, void* pUserData);


// Common mouse buttons.
#define DRGUI_MOUSE_BUTTON_LEFT       1
#define DRGUI_MOUSE_BUTTON_RIGHT      2
#define DRGUI_MOUSE_BUTTON_MIDDLE     3

// Common key codes.
#define DRGUI_BACKSPACE               0x08
#define DRGUI_SHIFT                   0x10
#define DRGUI_ESCAPE                  0x1B
#define DRGUI_PAGE_UP                 0x21
#define DRGUI_PAGE_DOWN               0x22
#define DRGUI_END                     0x23
#define DRGUI_HOME                    0x24
#define DRGUI_ARROW_LEFT              0x25
#define DRGUI_ARROW_UP                0x26
#define DRGUI_ARROW_DOWN              0x27
#define DRGUI_ARROW_RIGHT             0x28
#define DRGUI_DELETE                  0x2E

// Key state flags.
#define DRGUI_MOUSE_BUTTON_LEFT_DOWN   (1 << 0)
#define DRGUI_MOUSE_BUTTON_RIGHT_DOWN  (1 << 1)
#define DRGUI_MOUSE_BUTTON_MIDDLE_DOWN (1 << 2)
#define DRGUI_MOUSE_BUTTON_4_DOWN      (1 << 3)
#define DRGUI_MOUSE_BUTTON_5_DOWN      (1 << 4)
#define DRGUI_KEY_STATE_SHIFT_DOWN     (1 << 5)        // Whether or not a shift key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_CTRL_DOWN      (1 << 6)        // Whether or not a ctrl key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_ALT_DOWN       (1 << 7)        // Whether or not an alt key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_AUTO_REPEATED  (1 << 31)       // Whether or not the key press is generated due to auto-repeating. Only used with key down events.




/// Structure containing callbacks for painting routines.
struct drgui_painting_callbacks
{
    drgui_draw_begin_proc                          drawBegin;
    drgui_draw_end_proc                            drawEnd;

    drgui_set_clip_proc                            setClip;
    drgui_get_clip_proc                            getClip;

    drgui_draw_line_proc                           drawLine;
    drgui_draw_rect_proc                           drawRect;
    drgui_draw_rect_outline_proc                   drawRectOutline;
    drgui_draw_rect_with_outline_proc              drawRectWithOutline;
    drgui_draw_round_rect_proc                     drawRoundRect;
    drgui_draw_round_rect_outline_proc             drawRoundRectOutline;
    drgui_draw_round_rect_with_outline_proc        drawRoundRectWithOutline;
    drgui_draw_text_proc                           drawText;
    drgui_draw_image_proc                          drawImage;

    drgui_create_font_proc                         createFont;
    drgui_delete_font_proc                         deleteFont;
    drgui_get_font_size_proc                       getFontSize;
    drgui_get_font_metrics_proc                    getFontMetrics;
    drgui_get_glyph_metrics_proc                   getGlyphMetrics;
    drgui_measure_string_proc                      measureString;
    drgui_get_text_cursor_position_from_point_proc getTextCursorPositionFromPoint;
    drgui_get_text_cursor_position_from_char_proc  getTextCursorPositionFromChar;

    drgui_create_image_proc                        createImage;
    drgui_delete_image_proc                        deleteImage;
    drgui_get_image_size_proc                      getImageSize;
};

struct drgui_image
{
    /// A pointer to the context that owns this image.
    drgui_context* pContext;

    /// The resource handle that is passed around to the callback functions.
    drgui_resource hResource;
};

struct drgui_font
{
    /// A pointer to the context that owns this font.
    drgui_context* pContext;

    /// The font family.
    char family[DRGUI_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    drgui_font_weight weight;

    /// The fon't slant.
    drgui_font_slant slant;

    /// The fon't rotation.
    float rotation;

    /// The number of internal fonts in <pInternalFonts>
    size_t internalFontCount;

    /// A GUI font is actually a collection of font objects with the same family and style, but varying sizes. The variance
    /// in sizes is used to implement scaling. There is an internal font resource for each font size which are stored in a
    /// simple dynamically sized array. The first element in the array is the internal font representing the properties that
    /// were passed in to drgui_create_font().
    drgui_resource* pInternalFonts;
};


struct drgui_element
{
    /// A pointer to the context that owns this element. This should never be null for valid elements.
    drgui_context* pContext;


    /// A pointer to the parent element. This can be null in which case this element is the parent.
    drgui_element* pParent;

    /// A pointer to the first child element.
    drgui_element* pFirstChild;

    /// A pointer to the last child element.
    drgui_element* pLastChild;

    /// A pointer to the next sibling element.
    drgui_element* pNextSibling;

    /// A pointer ot the previous sibing element.
    drgui_element* pPrevSibling;


    /// A pointer to the next dead element. When an element is deleted during an event handler it is not deleted straight away but
    /// rather at the end of the current batch of event processing. Dead elements are stored in a linked list, with this pointer
    /// acting as the link between items. This will be null if the element is the last in the list, or is not marked as dead. Note
    /// that this should not be used to check if the element is marked as dead - use the IS_ELEMENT_DEAD flag instead.
    drgui_element* pNextDeadElement;


    /// The type of the element, as a string. This is only every used by the host application, and is intended to be used as way
    /// to selectively perform certain operations on specific types of GUI elements.
    char type[64];


    /// The absolute position of the element on the x axis. A position of 0 is the left side of the surface it is attached to.
    float absolutePosX;

    /// The absolute position of the element on the y axis. A position of 0 is the top of the surface it is attached to.
    float absolutePosY;

    /// The width of the element.
    float width;

    /// The height of the element.
    float height;


    /// The scale to apply to child elements on the x axis.
    float innerScaleX;

    /// The scale to apply to child elements on the y axis.
    float innerScaleY;


    /// The cursor. Defaults to drge_cursor_default.
    drgui_cursor_type cursor;


    /// Boolean flags.
    unsigned int flags;


    /// The function to call when the element's relative position moves.
    drgui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    drgui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    drgui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    drgui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    drgui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    drgui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    drgui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    drgui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    drgui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    drgui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    drgui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    drgui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    drgui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    drgui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    drgui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    drgui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    drgui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    drgui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    drgui_on_release_keyboard_proc onReleaseKeyboard;


    /// The size of the extra data.
    size_t extraDataSize;

    /// A pointer to the extra data.
    drgui_byte pExtraData[1];
};

struct drgui_context
{
    /// The paiting context.
    void* pPaintingContext;

    /// The painting callbacks.
    drgui_painting_callbacks paintingCallbacks;


    /// The inbound event counter. This is incremented with drgui_begin_inbound_event() and decremented with
    /// drgui_end_inbound_event(). We use this to determine whether or not an inbound event is being processed.
    int inboundEventCounter;

    /// The outbound event counter that we use as the "lock" for outbound events. All outbound events are posted from
    /// inbound events, and all inbound events are already synchronized so we don't need to use a mutex. This is mainly
    /// used as a way to check for erroneous outbound event generation.
    int outboundEventLockCounter;

    /// A pointer to the first element that has been marked as dead. Elements marked as dead are stored as a linked list.
    drgui_element* pFirstDeadElement;

    /// A pointer to the element that is sitting directly under the mouse. This is updated on every inbound mouse move event
    /// and is used for determining when a mouse enter/leave event needs to be posted.
    drgui_element* pElementUnderMouse;

    /// A pointer to the element with the mouse capture.
    drgui_element* pElementWithMouseCapture;

    /// A pointer to the element with the keyboard focus.
    drgui_element* pElementWithKeyboardCapture;

    /// A pointer to the element that wants the keyboard focus. If for some reason an element isn't able to immediately
    /// capture the keyboard (such as while in the middle of a release_keyboard event handler) this will be set to that
    /// particular element. This will then be used to capture the keyboard at a later time when it is able.
    drgui_element* pElementWantingKeyboardCapture;

    /// The current cursor.
    drgui_cursor_type currentCursor;

    /// Boolean flags.
    unsigned int flags;


    /// The global event callback to call when an element is marked as dirty.
    drgui_on_dirty_proc onGlobalDirty;

    /// The global event handler to call when an element captures the mouse.
    drgui_on_capture_mouse_proc onGlobalCaptureMouse;

    /// The global event handler to call when an element releases the mouse.
    drgui_on_release_mouse_proc onGlobalReleaseMouse;

    /// The global event handler to call when an element captures the keyboard.
    drgui_on_capture_keyboard_proc onGlobalCaptureKeyboard;

    /// The global event handler to call when an element releases the keyboard.
    drgui_on_release_keyboard_proc onGlobalReleaseKeyboard;

    /// The global event handler to call when the system cursor needs to change.
    drgui_on_change_cursor_proc onChangeCursor;


    /// The function to call when a log message is posted.
    drgui_on_log onLog;



    /// A pointer to the top level element that was passed in from the last inbound mouse move event.
    drgui_element* pLastMouseMoveTopLevelElement;

    /// The position of the mouse that was passed in from the last inbound mouse move event.
    float lastMouseMovePosX;
    float lastMouseMovePosY;


    /// A pointer to the top-level element that is currently in the process of being marked as dirty. This is set in drgui_begin_auto_dirty()
    /// and cleared in drgui_end_auto_dirty().
    drgui_element* pDirtyTopLevelElement;

    /// The current dirty rectangle, relative to pDirtyTopLevelElement.
    drgui_rect dirtyRect;

    /// The counter to use when determining whether or not an on_dirty event needs to be posted. This is incremented with
    /// drgui_begin_auto_dirty() and decremented with drgui_end_auto_dirty(). When the counter is decremented and hits
    /// zero, the on_dirty event will be posted.
    unsigned int dirtyCounter;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

/// Creates a context.
drgui_context* drgui_create_context();

/// Deletes a context and everything that it created.
void drgui_delete_context(drgui_context* pContext);



/////////////////////////////////////////////////////////////////
// Events

/// Posts a mouse leave inbound event.
///
/// @remarks
///     The intention behind this event is to allow the application to let dr_gui know that the mouse have left the window. Since dr_gui does
///     not have any notion of a window it must rely on the host application to notify it.
void drgui_post_inbound_event_mouse_leave(drgui_element* pTopLevelElement);

/// Posts a mouse move inbound event.
void drgui_post_inbound_event_mouse_move(drgui_element* pTopLevelElement, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button down inbound event.
void drgui_post_inbound_event_mouse_button_down(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button up inbound event.
void drgui_post_inbound_event_mouse_button_up(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button double-clicked inbound event.
void drgui_post_inbound_event_mouse_button_dblclick(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse wheel inbound event.
void drgui_post_inbound_event_mouse_wheel(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a key down inbound event.
void drgui_post_inbound_event_key_down(drgui_context* pContext, drgui_key key, int stateFlags);

/// Posts a key up inbound event.
void drgui_post_inbound_event_key_up(drgui_context* pContext, drgui_key key, int stateFlags);

/// Posts a printable key down inbound event.
///
/// @remarks
///     The \c character argument should be a UTF-32 code point.
void drgui_post_inbound_event_printable_key_down(drgui_context* pContext, unsigned int character, int stateFlags);


/// Registers the global on_dirty event callback.
///
/// @remarks
///     This is called whenever a region of an element is marked as dirty and allows an application to mark the region of the
///     container window as dirty to trigger an operating system level repaint of the window.
void drgui_set_global_on_dirty(drgui_context* pContext, drgui_on_dirty_proc onDirty);

/// Registers the global on_capture_mouse event callback.
///
/// @remarks
///     This is called whenever an element receives an the mouse capture and allows an application to do operating system level
///     mouse captures against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_capture_mouse(drgui_context* pContext, drgui_on_capture_mouse_proc onCaptureMouse);

/// Registers the global on_release_mouse event callback.
///
/// @remarks
///     This is called whenever an element loses an the mouse capture and allows an application to do operating system level
///     mouse releases against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_release_mouse(drgui_context* pContext, drgui_on_release_mouse_proc onReleaseMouse);

/// Registers the global on_capture_keyboard event callback.
///
/// @remarks
///     This is called whenever an element receives an the keyboard capture and allows an application to do an operating system level
///     keyboard focus against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_capture_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onCaptureKeyboard);

/// Registers the global on_release_keyboard event callback.
///
/// @remarks
///     This is called whenever an element loses an the keyboard capture and allows an application to do an operating system level
///     keyboard release against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_release_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onReleaseKeyboard);

/// Sets the global on_change_cursor event callback.
///
/// @remarks
///     This is called whenever the operating system needs to change the cursor.
void drgui_set_global_on_change_cursor(drgui_context* pContext, drgui_on_change_cursor_proc onChangeCursor);


/// Registers the callback to call when a log message is posted.
void drgui_set_on_log(drgui_context* pContext, drgui_on_log onLog);




/////////////////////////////////////////////////////////////////
// Elements

/// Creates an element.
drgui_element* drgui_create_element(drgui_context* pContext, drgui_element* pParent, size_t extraDataSize, const void* pExtraData);

/// Deletes and element.
void drgui_delete_element(drgui_element* pElement);


/// Retrieves the size of the extra data of the given element, in bytes.
size_t drgui_get_extra_data_size(drgui_element* pElement);

/// Retrieves a pointer to the extra data of the given element.
void* drgui_get_extra_data(drgui_element* pElement);


/// Sets the type of the element.
///
/// The type name cannot be more than 63 characters in length.
bool drgui_set_type(drgui_element* pElement, const char* type);

/// Retrieves the type fo the element.
const char* drgui_get_type(drgui_element* pElement);

/// Determines whether or not the given element is of the given type.
bool drgui_is_of_type(drgui_element* pElement, const char* type);


/// Hides the given element.
void drgui_hide(drgui_element *pElement);

/// Shows the given element.
void drgui_show(drgui_element* pElement);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return true. Use drgui_is_visible_recursive() to do
///     a recursive visibility check.
bool drgui_is_visible(const drgui_element* pElement);

/// Recursively determines whether or not the element is marked as visible.
bool drgui_is_visible_recursive(const drgui_element* pElement);


/// Disables clipping against the parent for the given element.
void drgui_disable_clipping(drgui_element* pElement);

/// Enables clipping against the parent for the given element.
void drgui_enable_clipping(drgui_element* pElement);

/// Determines whether or not clipping is enabled for the given element.
bool drgui_is_clipping_enabled(const drgui_element* pElement);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with drgui_release_mosue().
void drgui_capture_mouse(drgui_element* pElement);

/// Releases the mouse capture.
void drgui_release_mouse(drgui_context* pContext);

/// Retrieves a pointer to the element with the mouse capture.
drgui_element* drgui_get_element_with_mouse_capture(drgui_context* pContext);


/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with drgui_release_keyboard().
void drgui_capture_keyboard(drgui_element* pElement);

/// Releases the keyboard capture.
void drgui_release_keyboard(drgui_context* pContext);

/// Retrieves a pointer to the element with the keyboard capture.
drgui_element* drgui_get_element_with_keyboard_capture(drgui_context* pContext);


/// Sets the cursor to use when the mouse enters the given GUI element.
void drgui_set_cursor(drgui_element* pElement, drgui_cursor_type cursor);

/// Retrieves the cursor to use when the mouse enters the given GUI element.
drgui_cursor_type drgui_get_cursor(drgui_element* pElement);


//// Events ////

/// Registers the on_move event callback.
void drgui_set_on_move(drgui_element* pElement, drgui_on_move_proc callback);

/// Registers the on_size event callback.
void drgui_set_on_size(drgui_element* pElement, drgui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void drgui_set_on_mouse_enter(drgui_element* pElement, drgui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void drgui_set_on_mouse_leave(drgui_element* pElement, drgui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void drgui_set_on_mouse_move(drgui_element* pElement, drgui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void drgui_set_on_mouse_button_down(drgui_element* pElement, drgui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void drgui_set_on_mouse_button_up(drgui_element* pElement, drgui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void drgui_set_on_mouse_button_dblclick(drgui_element* pElement, drgui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void drgui_set_on_mouse_wheel(drgui_element* pElement, drgui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void drgui_set_on_key_down(drgui_element* pElement, drgui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void drgui_set_on_key_up(drgui_element* pElement, drgui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void drgui_set_on_printable_key_down(drgui_element* pElement, drgui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void drgui_set_on_paint(drgui_element* pElement, drgui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void drgui_set_on_dirty(drgui_element* pElement, drgui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void drgui_set_on_hittest(drgui_element* pElement, drgui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void drgui_set_on_capture_mouse(drgui_element* pElement, drgui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void drgui_set_on_release_mouse(drgui_element* pElement, drgui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void drgui_set_on_capture_keyboard(drgui_element* pElement, drgui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void drgui_set_on_release_keyboard(drgui_element* pElement, drgui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and drgui_is_point_inside_element() is that the latter will use hit testing.
bool drgui_is_point_inside_element_bounds(const drgui_element* pElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
bool drgui_is_point_inside_element(drgui_element* pElement, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
drgui_element* drgui_find_element_under_point(drgui_element* pTopLevelElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
bool drgui_is_element_under_mouse(drgui_element* pTopLevelElement);



//// Hierarchy ////

/// Detaches the given element from it's parent.
void drgui_detach(drgui_element* pChildElement);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void drgui_append(drgui_element* pChildElement, drgui_element* pParentElement);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void drgui_prepend(drgui_element* pChildElement, drgui_element* pParentElement);

/// Appends the given element to the given sibling.
void drgui_append_sibling(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo);

/// Prepends the given element to the given sibling.
void drgui_prepend_sibling(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pElement is the top level element, the return value will be pElement.
drgui_element* drgui_find_top_level_element(drgui_element* pElement);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use drgui_is_ancestor() to do a recursive traversal.
bool drgui_is_parent(drgui_element* pParentElement, drgui_element* pChildElement);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use drgui_is_descendant() to do a recursive traversal.
bool drgui_is_child(drgui_element* pChildElement, drgui_element* pParentElement);

/// Determines whether or not the given element is an ancestor of the other.
bool drgui_is_ancestor(drgui_element* pAncestorElement, drgui_element* pChildElement);

/// Determines whether or not the given element is a descendant of the other.
bool drgui_is_descendant(drgui_element* pChildElement, drgui_element* pAncestorElement);



//// Layout ////

/// Sets the absolute position of the given element.
void drgui_set_absolute_position(drgui_element* pElement, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void drgui_get_absolute_position(const drgui_element* pElement, float* positionXOut, float* positionYOut);
float drgui_get_absolute_position_x(const drgui_element* pElement);
float drgui_get_absolute_position_y(const drgui_element* pElement);


/// Sets the relative position of the given element.
void drgui_set_relative_position(drgui_element* pElement, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void drgui_get_relative_position(const drgui_element* pElement, float* relativePosXOut, float* relativePosYOut);
float drgui_get_relative_position_x(const drgui_element* pElement);
float drgui_get_relative_position_y(const drgui_element* pElement);


/// Sets the size of the given element.
void drgui_set_size(drgui_element* pElement, float width, float height);

/// Retrieves the size of the given element.
void drgui_get_size(const drgui_element* pElement, float* widthOut, float* heightOut);
float drgui_get_width(const drgui_element* pElement);
float drgui_get_height(const drgui_element* pElement);


/// Sets the inner scale of the given element.
///
/// @remarks
///     This does not scale the element itself - only it's children.
void drgui_set_inner_scale(drgui_element* pElement, float innerScaleX, float innerScaleY);

/// Retrieves the inner scale of the given element.
///
/// @remarks
///     This is a direct accessor and not recursive. Use drgui_get_absolute_inner_scale() for the actual
///     inner scale.
void drgui_get_inner_scale(drgui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut);

/// Recursively retrieves the absolute scale fo the given element.
void drgui_get_absolute_inner_scale(drgui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut);



/// Retrieves the absolute rectangle for the given element.
drgui_rect drgui_get_absolute_rect(const drgui_element* pElement);

/// Retrieves the relative rectangle for the given element.
drgui_rect drgui_get_relative_rect(const drgui_element* pElement);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to drgui_make_rect(0, 0, drgui_get_width(pElement), drgui_get_height(pElement));
drgui_rect drgui_get_local_rect(const drgui_element* pElement);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
bool drgui_register_painting_callbacks(drgui_context* pContext, void* pPaintingContext, drgui_painting_callbacks callbacks);


/// Performs a recursive traversal of all visible elements in the given rectangle.
///
/// @param pParentElement [in] A pointer to the element to iterate.
///
/// @remarks
///     pParentElement will be included in the iteration is it is within the rectangle.
///     @par
///     The rectangle should be relative to pParentElement.
///     @par
///     The iteration callback function takes a pointer to a rectangle structure that represents the visible portion of the
///     element. This pointer can be modified by the callback to create an adjusted rectangle which can be used for clipping.
bool drgui_iterate_visible_elements(drgui_element* pParentElement, drgui_rect relativeRect, drgui_visible_iteration_proc callback, void* pUserData);


/// Disable's automatic dirtying of elements.
void drgui_disable_auto_dirty(drgui_context* pContext);

/// Enable's automatic dirtying of elements.
void drgui_enable_auto_dirty(drgui_context* pContext);

/// Determines whether or not automatic dirtying is enabled.
bool drgui_is_auto_dirty_enabled(drgui_context* pContext);


/// Marks a region of the given element as dirty.
///
/// @remarks
///     This will not redraw the element immediately, but instead post a paint event.
void drgui_dirty(drgui_element* pElement, drgui_rect relativeRect);


/// Draws the given element.
///
/// @remarks
///     Do not call this on one element, then again on it's children. Any children that fall inside the specified
///     rectangle will also be redrawn.
///     @par
///     This will call painting event handlers which will give the application time to do custom drawing.
///     @par
///     When using easy_draw to do drawing, pPaintData must be set to a pointer to the relevant easydraw_surface object.
void drgui_draw(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);

/// Retrieves the current clipping rectangle.
void drgui_get_clip(drgui_element* pElement, drgui_rect* pRelativeRect, void* pPaintData);

/// Sets the clipping rectangle to apply to all future draw operations on this element.
void drgui_set_clip(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);

/// Draws a rectangle on the given element.
void drgui_draw_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, void* pPaintData);

/// Draws the outline of a rectangle on the given element.
void drgui_draw_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle with an outline on the given element.
void drgui_draw_rect_with_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, drgui_color outlineColor, void* pPaintData);

/// Draws a rectangle with rounded corners on the given element.
void drgui_draw_round_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, void* pPaintData);

/// Draws the outline of a rectangle with rounded corners on the given element.
void drgui_draw_round_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle and it's outline with rounded corners on the given element.
void drgui_draw_round_rect_with_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData);

/// Draws a run of text on the given element.
///
/// @remarks
///     This does not do any complex formatting like multiple lines and whatnot. Complex formatting can be achieved with multiple
///     calls to this function.
///     @par
///     \c textSizeInBytes can be -1 in which case the text string is treated as null terminated.
void drgui_draw_text(drgui_element* pElement, drgui_font* pFont, const char* text, int textLengthInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData);

/// Draws an image.
void drgui_draw_image(drgui_element* pElement, drgui_image* pImage, drgui_draw_image_args* pArgs, void* pPaintData);


/// Creates a font resource.
drgui_font* drgui_create_font(drgui_context* pContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation);

/// Deletes a font resource.
void drgui_delete_font(drgui_font* pFont);

/// Retrieves the metrics of the given font.
bool drgui_get_font_metrics(drgui_font* pFont, float scaleX, float scaleY, drgui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the given font based on the inner scale of the given element.
bool drgui_get_font_metrics_by_element(drgui_font* pFont, drgui_element* pElement, drgui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font.
bool drgui_get_glyph_metrics(drgui_font* pFont, unsigned int utf32, float scaleX, float scaleY, drgui_glyph_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font at the scale of the given element's inner scale.
bool drgui_get_glyph_metrics_by_element(drgui_font* pFont, unsigned int utf32, drgui_element* pElement, drgui_glyph_metrics* pMetricsOut);

/// Retrieves the dimensions of the given string when drawn with the given font at the given scale.
///
/// @remarks
///     When the length of the text is 0, the width will be set to 0 and the height will be set to the line height.
///     @par
///     <scaleX> and <scaleY> should be set to the scale at which the font will be drawn.
bool drgui_measure_string(drgui_font* pFont, const char* text, size_t textLengthInBytes, float scaleX, float scaleY, float* pWidthOut, float* pHeightOut);

/// Retrieves the dimensions fo the given string when drawing with the given font at the scale of the given element.
bool drgui_measure_string_by_element(drgui_font* pFont, const char* text, size_t textLengthInBytes, drgui_element* pElement, float* pWidthOut, float* pHeightOut);

/// Retrieves the position to place a text cursor based on the given point for the given string when drawn with the given font.
bool drgui_get_text_cursor_position_from_point(drgui_font* pFont, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float scaleX, float scaleY, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut);

/// Retrieves the position to palce a text cursor based on the character at the given index for the given string when drawn with the given font.
bool drgui_get_text_cursor_position_from_char(drgui_font* pFont, const char* text, unsigned int characterIndex, float scaleX, float scaleY, float* pTextCursorPosXOut);



/// Creates an image that can be passed to dr2d_draw_image().
///
/// @remarks
///     Images are immutable. If the data of an image needs to change, the image must be deleted and re-created.
///     @par
///     The image data must be in 32-bit, RGBA format where each component is in the range of 0 - 255.
drgui_image* drgui_create_image(drgui_context* pContext, unsigned int width, unsigned int height, unsigned int stride, const void* pData);

/// Deletes the given image.
void drgui_delete_image(drgui_image* pImage);

/// Retrieves the size of the given image.
void drgui_get_image_size(drgui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void drgui_on_size_fit_children_to_parent(drgui_element* pElement, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
bool drgui_pass_through_hit_test(drgui_element* pElement, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void drgui_draw_border(drgui_element* pElement, float borderWidth, drgui_color color, void* pUserData);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Creates a color object from a set of RGBA color components.
drgui_color drgui_rgba(drgui_byte r, drgui_byte g, drgui_byte b, drgui_byte a);

/// Creates a color object from a set of RGB color components.
drgui_color drgui_rgb(drgui_byte r, drgui_byte g, drgui_byte b);

/// Clamps the given rectangle to another.
drgui_rect drgui_clamp_rect(drgui_rect rect, drgui_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
bool drgui_clamp_rect_to_element(const drgui_element* pElement, drgui_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
drgui_rect drgui_make_rect_relative(const drgui_element* pElement, drgui_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
drgui_rect drgui_make_rect_absolute(const drgui_element* pElement, drgui_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void drgui_make_point_relative(const drgui_element* pElement, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void drgui_make_point_absolute(const drgui_element* pElement, float* positionX, float* positionY);

/// Creates a drgui_rect object.
drgui_rect drgui_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
drgui_rect drgui_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
drgui_rect drgui_grow_rect(drgui_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
drgui_rect drgui_scale_rect(drgui_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
drgui_rect drgui_offset_rect(drgui_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
drgui_rect drgui_rect_union(drgui_rect rect0, drgui_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, false will be returned. If, however, the point
///     is sitting on the left or top border, true will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return true for both elements, which we don't want.
bool drgui_rect_contains_point(drgui_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
bool drgui_rect_equal(drgui_rect rect0, drgui_rect rect1);



/////////////////////////////////////////////////////////////////
//
// EASY_DRAW-SPECIFIC API
//
/////////////////////////////////////////////////////////////////
#ifndef DRGUI_NO_DR_2D

/// A covenience function for creating a new context and registering the easy_draw painting callbacks.
///
/// @remarks
///     This is equivalent to drgui_create_context() followed by drgui_register_dr_2d_callbacks().
drgui_context* drgui_create_context_dr_2d(dr2d_context* pDrawingContext);

/// Registers the drawing callbacks for use with easy_draw.
///
/// @remarks
///     The user data of each callback is assumed to be a pointer to an easydraw_surface object.
void drgui_register_dr_2d_callbacks(drgui_context* pContext, dr2d_context* pDrawingContext);

#endif


#ifdef __cplusplus
}
#endif

#endif  //dr_gui_h



///////////////////////////////////////////////////////////////////////////////
//
// IMPLEMENTATION
//
///////////////////////////////////////////////////////////////////////////////
#ifdef DR_GUI_IMPLEMENTATION
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <errno.h>
#include <float.h>
#include <math.h>

#ifndef DRGUI_PRIVATE
#define DRGUI_PRIVATE static
#endif

/////////////////////////////////////////////////////////////////
//
// PRIVATE CORE API
//
/////////////////////////////////////////////////////////////////


// Context Flags
#define IS_CONTEXT_DEAD                     (1U << 0)
#define IS_AUTO_DIRTY_DISABLED              (1U << 1)
#define IS_RELEASING_KEYBOARD               (1U << 2)

// Element Flags
#define IS_ELEMENT_HIDDEN                   (1U << 0)
#define IS_ELEMENT_CLIPPING_DISABLED        (1U << 1)
#define IS_ELEMENT_DEAD                     (1U << 31)


static int drgui__strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
{
#ifdef _MSC_VER
    return strcpy_s(dst, dstSizeInBytes, src);
#else
    if (dst == 0) {
        return EINVAL;
    }
    if (dstSizeInBytes == 0) {
        return ERANGE;
    }
    if (src == 0) {
        dst[0] = '\0';
        return EINVAL;
    }

    size_t i;
    for (i = 0; i < dstSizeInBytes && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (i < dstSizeInBytes) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return ERANGE;
#endif
}

int drgui__strncpy_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
#ifdef _MSC_VER
    return strncpy_s(dst, dstSizeInBytes, src, count);
#else
    if (dst == 0) {
        return EINVAL;
    }
    if (dstSizeInBytes == 0) {
        return EINVAL;
    }
    if (src == 0) {
        dst[0] = '\0';
        return EINVAL;
    }

    size_t maxcount = count;
    if (count == ((size_t)-1) || count >= dstSizeInBytes) {        // -1 = _TRUNCATE
        maxcount = dstSizeInBytes - 1;
    }

    size_t i;
    for (i = 0; i < maxcount && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (src[i] == '\0' || i == count || count == ((size_t)-1)) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return ERANGE;
#endif
}


/// Increments the inbound event counter
///
/// @remarks
///     This is called from every drgui_post_inbound_event_*() function and is used to keep track of whether or
///     not an inbound event is being processed. We need to track this because if we are in the middle of event
///     processing and an element is deleted, we want to delay it's deletion until the end of the event processing.
///     @par
///     Use drgui_end_inbound_event() to decrement the counter.
void drgui_begin_inbound_event(drgui_context* pContext);

/// Decrements the inbound event counter.
///
/// @remarks
///     This is called from every drgui_post_inbound_event_*() function.
///     @par
///     When the internal counter reaches zero, deleted elements will be garbage collected.
void drgui_end_inbound_event(drgui_context* pContext);

/// Determines whether or not inbound events are being processed.
///
/// @remarks
///     This is used to determine whether or not an element can be deleted immediately or should be garbage collected
///     at the end of event processing.
bool drgui_is_handling_inbound_event(const drgui_context* pContext);


/// Increments the outbound event counter.
///
/// @remarks
///     This will validate that the given element is allowed to have an event posted. When false is returned, nothing
///     will have been locked and the outbound event should be cancelled.
///     @par
///     This will return false if the given element has been marked as dead, or if there is some other reason it should
///     not be receiving events.
bool drgui_begin_outbound_event(drgui_element* pElement);

/// Decrements the outbound event counter.
void drgui_end_outbound_event(drgui_element* pElement);

/// Determines whether or not and outbound event is being processed.
bool drgui_is_handling_outbound_event(drgui_context* pContext);


/// Marks the given element as dead.
void drgui_mark_element_as_dead(drgui_element* pElement);

/// Determines whether or not the given element is marked as dead.
bool drgui_is_element_marked_as_dead(const drgui_element* pElement);

/// Deletes every element that has been marked as dead.
void drgui_delete_elements_marked_as_dead(drgui_context* pContext);


/// Marks the given context as deleted.
void drgui_mark_context_as_dead(drgui_context* pContext);

/// Determines whether or not the given context is marked as dead.
bool drgui_is_context_marked_as_dead(const drgui_context* pContext);


/// Deletes the given context for real.
///
/// If a context is deleted during the processing of an inbound event it will not be deleting immediately - this
/// will delete the context for real.
void drgui_delete_context_for_real(drgui_context* pContext);

/// Deletes the given element for real.
///
/// Sometimes an element will not be deleted straight away but instead just marked as dead. We use this to delete
/// the given element for real.
void drgui_delete_element_for_real(drgui_element* pElement);


/// Orphans the given element without triggering a redraw of the parent nor the child.
void drgui_detach_without_redraw(drgui_element* pChildElement);

/// Appends the given element without first detaching it from the old parent, nor does it post a redraw.
void drgui_append_without_detach_or_redraw(drgui_element* pChildElement, drgui_element* pParentElement);

/// Appends the given element without first detaching it from the old parent.
void drgui_append_without_detach(drgui_element* pChildElement, drgui_element* pParentElement);

/// Prepends the given element without first detaching it from the old parent, nor does it post a redraw.
void drgui_prepend_without_detach_or_redraw(drgui_element* pChildElement, drgui_element* pParentElement);

/// Prepends the given element without first detaching it from the old parent.
void drgui_prepend_without_detach(drgui_element* pChildElement, drgui_element* pParentElement);

/// Appends an element to another as it's sibling, but does not detach it from the previous parent nor trigger a redraw.
void drgui_append_sibling_without_detach_or_redraw(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo);

/// Appends an element to another as it's sibling, but does not detach it from the previous parent.
void drgui_append_sibling_without_detach(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo);

/// Prepends an element to another as it's sibling, but does not detach it from the previous parent nor trigger a redraw.
void drgui_prepend_sibling_without_detach_or_redraw(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo);

/// Prepends an element to another as it's sibling, but does not detach it from the previous parent.
void drgui_prepends_sibling_without_detach(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo);


/// Begins accumulating an invalidation rectangle.
void drgui_begin_auto_dirty(drgui_element* pElement, drgui_rect relativeRect);

/// Ends accumulating the invalidation rectangle and posts on_dirty is auto-dirty is enabled.
void drgui_end_auto_dirty(drgui_element* pElement);

/// Marks the given region of the given top level element as dirty, but only if automatic dirtying is enabled.
///
/// @remarks
///     This is equivalent to drgui_begin_auto_dirty() immediately followed by drgui_end_auto_dirty().
void drgui_auto_dirty(drgui_element* pTopLevelElement, drgui_rect rect);


/// Recursively applies the given offset to the absolute positions of the children of the given element.
///
/// @remarks
///     This is called when the absolute position of an element is changed.
void drgui_apply_offset_to_children_recursive(drgui_element* pParentElement, float offsetX, float offsetY);


/// The function to call when the mouse may have entered into a new element.
void drgui_update_mouse_enter_and_leave_state(drgui_context* pContext, drgui_element* pNewElementUnderMouse);


/// Functions for posting outbound events.
void drgui_post_outbound_event_move(drgui_element* pElement, float newRelativePosX, float newRelativePosY);
void drgui_post_outbound_event_size(drgui_element* pElement, float newWidth, float newHeight);
void drgui_post_outbound_event_mouse_enter(drgui_element* pElement);
void drgui_post_outbound_event_mouse_leave(drgui_element* pElement);
void drgui_post_outbound_event_mouse_move(drgui_element* pElement, int relativeMousePosX, int relativeMousePosY, int stateFlags);
void drgui_post_outbound_event_mouse_button_down(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
void drgui_post_outbound_event_mouse_button_up(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
void drgui_post_outbound_event_mouse_button_dblclick(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
void drgui_post_outbound_event_mouse_wheel(drgui_element* pElement, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
void drgui_post_outbound_event_key_down(drgui_element* pElement, drgui_key key, int stateFlags);
void drgui_post_outbound_event_key_up(drgui_element* pElement, drgui_key key, int stateFlags);
void drgui_post_outbound_event_printable_key_down(drgui_element* pElement, unsigned int character, int stateFlags);
void drgui_post_outbound_event_dirty(drgui_element* pElement, drgui_rect relativeRect);
void drgui_post_outbound_event_dirty_global(drgui_element* pElement, drgui_rect relativeRect);
void drgui_post_outbound_event_capture_mouse(drgui_element* pElement);
void drgui_post_outbound_event_capture_mouse_global(drgui_element* pElement);
void drgui_post_outbound_event_release_mouse(drgui_element* pElement);
void drgui_post_outbound_event_release_mouse_global(drgui_element* pElement);
void drgui_post_outbound_event_capture_keyboard(drgui_element* pElement, drgui_element* pPrevCapturedElement);
void drgui_post_outbound_event_capture_keyboard_global(drgui_element* pElement, drgui_element* pPrevCapturedElement);
void drgui_post_outbound_event_release_keyboard(drgui_element* pElement, drgui_element* pNewCapturedElement);
void drgui_post_outbound_event_release_keyboard_global(drgui_element* pElement, drgui_element* pNewCapturedElement);

/// Posts a log message.
void drgui_log(drgui_context* pContext, const char* message);

/// Retrieves the internal font that would be used when scaled by the given amount.
///
/// @remarks
///     If an internal font of the appropriate size has not yet been created, this function will create it.
DRGUI_PRIVATE drgui_resource drgui_get_internal_font_by_scale(drgui_font* pFont, float scaleY);


void drgui_begin_inbound_event(drgui_context* pContext)
{
    assert(pContext != NULL);

    pContext->inboundEventCounter += 1;
}

void drgui_end_inbound_event(drgui_context* pContext)
{
    assert(pContext != NULL);
    assert(pContext->inboundEventCounter > 0);

    pContext->inboundEventCounter -= 1;


    // Here is where we want to clean up any elements that are marked as dead. When events are being handled elements are not deleted
    // immediately but instead only marked for deletion. This function will be called at the end of event processing which makes it
    // an appropriate place for cleaning up dead elements.
    if (!drgui_is_handling_inbound_event(pContext))
    {
        drgui_delete_elements_marked_as_dead(pContext);

        // If the context has been marked for deletion than we will need to delete that too.
        if (drgui_is_context_marked_as_dead(pContext))
        {
            drgui_delete_context_for_real(pContext);
        }
    }
}

bool drgui_is_handling_inbound_event(const drgui_context* pContext)
{
    assert(pContext != NULL);

    return pContext->inboundEventCounter > 0;
}



bool drgui_begin_outbound_event(drgui_element* pElement)
{
    assert(pElement != NULL);
    assert(pElement->pContext != NULL);


    // We want to cancel the outbound event if the element is marked as dead.
    if (drgui_is_element_marked_as_dead(pElement)) {
        drgui_log(pElement->pContext, "WARNING: Attemping to post an event to an element that is marked for deletion.");
        return false;
    }


    // At this point everything should be fine so we just increment the count (which should never go above 1) and return true.
    pElement->pContext->outboundEventLockCounter += 1;

    return true;
}

void drgui_end_outbound_event(drgui_element* pElement)
{
    assert(pElement != NULL);
    assert(pElement->pContext != NULL);
    assert(pElement->pContext->outboundEventLockCounter > 0);

    pElement->pContext->outboundEventLockCounter -= 1;
}

bool drgui_is_handling_outbound_event(drgui_context* pContext)
{
    assert(pContext != NULL);
    return pContext->outboundEventLockCounter > 0;
}


void drgui_mark_element_as_dead(drgui_element* pElement)
{
    assert(pElement != NULL);
    assert(pElement->pContext != NULL);

    pElement->flags |= IS_ELEMENT_DEAD;


    if (pElement->pContext->pFirstDeadElement != NULL) {
        pElement->pNextDeadElement = pElement->pContext->pFirstDeadElement;
    }

    pElement->pContext->pFirstDeadElement = pElement;
}

bool drgui_is_element_marked_as_dead(const drgui_element* pElement)
{
    assert(pElement != NULL);

    return (pElement->flags & IS_ELEMENT_DEAD) != 0;
}

void drgui_delete_elements_marked_as_dead(drgui_context* pContext)
{
    assert(pContext != NULL);

    while (pContext->pFirstDeadElement != NULL)
    {
        drgui_element* pDeadElement = pContext->pFirstDeadElement;
        pContext->pFirstDeadElement = pContext->pFirstDeadElement->pNextDeadElement;

        drgui_delete_element_for_real(pDeadElement);
    }
}


void drgui_mark_context_as_dead(drgui_context* pContext)
{
    assert(pContext != NULL);
    assert(!drgui_is_context_marked_as_dead(pContext));

    pContext->flags |= IS_CONTEXT_DEAD;
}

bool drgui_is_context_marked_as_dead(const drgui_context* pContext)
{
    assert(pContext != NULL);

    return (pContext->flags & IS_CONTEXT_DEAD) != 0;
}



void drgui_delete_context_for_real(drgui_context* pContext)
{
    assert(pContext != NULL);

    // All elements marked as dead need to be deleted.
    drgui_delete_elements_marked_as_dead(pContext);

    free(pContext);
}

void drgui_delete_element_for_real(drgui_element* pElement)
{
    assert(pElement != NULL);

    free(pElement);
}


void drgui_detach_without_redraw(drgui_element* pElement)
{
    if (pElement->pParent != NULL) {
        if (pElement->pParent->pFirstChild == pElement) {
            pElement->pParent->pFirstChild = pElement->pNextSibling;
        }

        if (pElement->pParent->pLastChild == pElement) {
            pElement->pParent->pLastChild = pElement->pPrevSibling;
        }


        if (pElement->pPrevSibling != NULL) {
            pElement->pPrevSibling->pNextSibling = pElement->pNextSibling;
        }

        if (pElement->pNextSibling != NULL) {
            pElement->pNextSibling->pPrevSibling = pElement->pPrevSibling;
        }
    }

    pElement->pParent      = NULL;
    pElement->pPrevSibling = NULL;
    pElement->pNextSibling = NULL;
}

void drgui_append_without_detach_or_redraw(drgui_element* pChildElement, drgui_element* pParentElement)
{
    pChildElement->pParent = pParentElement;
    if (pChildElement->pParent != NULL) {
        if (pChildElement->pParent->pLastChild != NULL) {
            pChildElement->pPrevSibling = pChildElement->pParent->pLastChild;
            pChildElement->pPrevSibling->pNextSibling = pChildElement;
        }

        if (pChildElement->pParent->pFirstChild == NULL) {
            pChildElement->pParent->pFirstChild = pChildElement;
        }

        pChildElement->pParent->pLastChild = pChildElement;
    }
}

void drgui_append_without_detach(drgui_element* pChildElement, drgui_element* pParentElement)
{
    drgui_append_without_detach_or_redraw(pChildElement, pParentElement);
    drgui_auto_dirty(pChildElement, drgui_make_rect(0, 0, pChildElement->width, pChildElement->height));
}

void drgui_prepend_without_detach_or_redraw(drgui_element* pChildElement, drgui_element* pParentElement)
{
    pChildElement->pParent = pParentElement;
    if (pChildElement->pParent != NULL) {
        if (pChildElement->pParent->pFirstChild != NULL) {
            pChildElement->pNextSibling = pChildElement->pParent->pFirstChild;
            pChildElement->pNextSibling->pPrevSibling = pChildElement;
        }

        if (pChildElement->pParent->pLastChild == NULL) {
            pChildElement->pParent->pLastChild = pChildElement;
        }

        pChildElement->pParent->pFirstChild = pChildElement;
    }
}

void drgui_prepend_without_detach(drgui_element* pChildElement, drgui_element* pParentElement)
{
    drgui_prepend_without_detach_or_redraw(pChildElement, pParentElement);
    drgui_auto_dirty(pChildElement, drgui_make_rect(0, 0, pChildElement->width, pChildElement->height));
}

void drgui_append_sibling_without_detach_or_redraw(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo)
{
    assert(pElementToAppend   != NULL);
    assert(pElementToAppendTo != NULL);

    pElementToAppend->pParent = pElementToAppendTo->pParent;
    if (pElementToAppend->pParent != NULL)
    {
        pElementToAppend->pNextSibling = pElementToAppendTo->pNextSibling;
        pElementToAppend->pPrevSibling = pElementToAppendTo;

        pElementToAppendTo->pNextSibling->pPrevSibling = pElementToAppend;
        pElementToAppendTo->pNextSibling = pElementToAppend;

        if (pElementToAppend->pParent->pLastChild == pElementToAppendTo) {
            pElementToAppend->pParent->pLastChild = pElementToAppend;
        }
    }
}

void drgui_append_sibling_without_detach(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo)
{
    drgui_append_sibling_without_detach_or_redraw(pElementToAppend, pElementToAppendTo);
    drgui_auto_dirty(pElementToAppend, drgui_make_rect(0, 0, pElementToAppend->width, pElementToAppend->height));
}

void drgui_prepend_sibling_without_detach_or_redraw(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo)
{
    assert(pElementToPrepend   != NULL);
    assert(pElementToPrependTo != NULL);

    pElementToPrepend->pParent = pElementToPrependTo->pParent;
    if (pElementToPrepend->pParent != NULL)
    {
        pElementToPrepend->pPrevSibling = pElementToPrependTo->pNextSibling;
        pElementToPrepend->pNextSibling = pElementToPrependTo;

        pElementToPrependTo->pPrevSibling->pNextSibling = pElementToPrepend;
        pElementToPrependTo->pNextSibling = pElementToPrepend;

        if (pElementToPrepend->pParent->pFirstChild == pElementToPrependTo) {
            pElementToPrepend->pParent->pFirstChild = pElementToPrepend;
        }
    }
}

void drgui_prepend_sibling_without_detach(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo)
{
    drgui_prepend_sibling_without_detach_or_redraw(pElementToPrepend, pElementToPrependTo);
    drgui_auto_dirty(pElementToPrepend, drgui_make_rect(0, 0, pElementToPrepend->width, pElementToPrepend->height));
}


void drgui_begin_auto_dirty(drgui_element* pElement, drgui_rect relativeRect)
{
    assert(pElement           != NULL);
    assert(pElement->pContext != NULL);

    if (drgui_is_auto_dirty_enabled(pElement->pContext))
    {
        drgui_context* pContext = pElement->pContext;

        if (pContext->pDirtyTopLevelElement == NULL) {
            pContext->pDirtyTopLevelElement = drgui_find_top_level_element(pElement);
        }

        assert(pContext->pDirtyTopLevelElement == drgui_find_top_level_element(pElement));


        pContext->dirtyRect = drgui_rect_union(pContext->dirtyRect, drgui_make_rect_absolute(pElement, &relativeRect));
        pContext->dirtyCounter += 1;
    }
}

void drgui_end_auto_dirty(drgui_element* pElement)
{
    assert(pElement           != NULL);
    assert(pElement->pContext != NULL);

    drgui_context* pContext = pElement->pContext;
    if (drgui_is_auto_dirty_enabled(pContext))
    {
        assert(pContext->pDirtyTopLevelElement != NULL);
        assert(pContext->dirtyCounter > 0);

        pContext->dirtyCounter -= 1;
        if (pContext->dirtyCounter == 0)
        {
            drgui_dirty(pContext->pDirtyTopLevelElement, pContext->dirtyRect);

            pContext->pDirtyTopLevelElement = NULL;
            pContext->dirtyRect             = drgui_make_inside_out_rect();
        }
    }
}

void drgui_auto_dirty(drgui_element* pElement, drgui_rect relativeRect)
{
    assert(pElement != NULL);
    assert(pElement->pContext != NULL);

    if (drgui_is_auto_dirty_enabled(pElement->pContext)) {
        drgui_begin_auto_dirty(pElement, relativeRect);
        drgui_end_auto_dirty(pElement);
    }
}


void drgui__change_cursor(drgui_element* pElement, drgui_cursor_type cursor)
{
    if (pElement == NULL || pElement->pContext == NULL) {
        return;
    }

    pElement->pContext->currentCursor = cursor;
    
    if (pElement->pContext->onChangeCursor) {
        pElement->pContext->onChangeCursor(pElement, cursor);
    }
}



void drgui_apply_offset_to_children_recursive(drgui_element* pParentElement, float offsetX, float offsetY)
{
    assert(pParentElement != NULL);

    for (drgui_element* pChild = pParentElement->pFirstChild; pChild != NULL; pChild = pChild->pNextSibling)
    {
        drgui_begin_auto_dirty(pParentElement, drgui_get_local_rect(pParentElement));
        {
            pChild->absolutePosX += offsetX;
            pChild->absolutePosY += offsetY;

            drgui_apply_offset_to_children_recursive(pChild, offsetX, offsetY);
        }
        drgui_end_auto_dirty(pParentElement);
    }
}

DRGUI_PRIVATE void drgui_post_on_mouse_leave_recursive(drgui_context* pContext, drgui_element* pNewElementUnderMouse, drgui_element* pOldElementUnderMouse)
{
    (void)pContext;

    drgui_element* pOldAncestor = pOldElementUnderMouse;
    while (pOldAncestor != NULL)
    {
        bool isOldElementUnderMouse = pNewElementUnderMouse == pOldAncestor || drgui_is_ancestor(pOldAncestor, pNewElementUnderMouse);
        if (!isOldElementUnderMouse)
        {
            drgui_post_outbound_event_mouse_leave(pOldAncestor);
        }

        pOldAncestor = pOldAncestor->pParent;
    }
}

DRGUI_PRIVATE void drgui_post_on_mouse_enter_recursive(drgui_context* pContext, drgui_element* pNewElementUnderMouse, drgui_element* pOldElementUnderMouse)
{
    if (pNewElementUnderMouse == NULL) {
        return;
    }


    if (pNewElementUnderMouse->pParent != NULL) {
        drgui_post_on_mouse_enter_recursive(pContext, pNewElementUnderMouse->pParent, pOldElementUnderMouse);
    }

    bool wasNewElementUnderMouse = pOldElementUnderMouse == pNewElementUnderMouse || drgui_is_ancestor(pNewElementUnderMouse, pOldElementUnderMouse);
    if (!wasNewElementUnderMouse)
    {
        drgui_post_outbound_event_mouse_enter(pNewElementUnderMouse);
    }
}

void drgui_update_mouse_enter_and_leave_state(drgui_context* pContext, drgui_element* pNewElementUnderMouse)
{
    if (pContext == NULL) {
        return;
    }

    drgui_element* pOldElementUnderMouse = pContext->pElementUnderMouse;
    if (pOldElementUnderMouse != pNewElementUnderMouse)
    {
        // We don't change the enter and leave state if an element is capturing the mouse.
        if (pContext->pElementWithMouseCapture == NULL)
        {
            pContext->pElementUnderMouse = pNewElementUnderMouse;

            drgui_cursor_type newCursor = drgui_cursor_default;
            if (pNewElementUnderMouse != NULL) {
                newCursor = pNewElementUnderMouse->cursor;
            }

            if (newCursor != pContext->currentCursor) {
                drgui__change_cursor(pNewElementUnderMouse, newCursor);
            }



            // The the event handlers below, remember that ancestors are considered hovered if a descendant is the element under the mouse.

            // on_mouse_leave
            drgui_post_on_mouse_leave_recursive(pContext, pNewElementUnderMouse, pOldElementUnderMouse);

            // on_mouse_enter
            drgui_post_on_mouse_enter_recursive(pContext, pNewElementUnderMouse, pOldElementUnderMouse);
        }
    }
}


void drgui_post_outbound_event_move(drgui_element* pElement, float newRelativePosX, float newRelativePosY)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMove) {
            pElement->onMove(pElement, newRelativePosX, newRelativePosY);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_size(drgui_element* pElement, float newWidth, float newHeight)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onSize) {
            pElement->onSize(pElement, newWidth, newHeight);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_enter(drgui_element* pElement)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseEnter) {
            pElement->onMouseEnter(pElement);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_leave(drgui_element* pElement)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseLeave) {
            pElement->onMouseLeave(pElement);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_move(drgui_element* pElement, int relativeMousePosX, int relativeMousePosY, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseMove)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->onMouseMove(pElement, (int)(relativeMousePosX / scaleX), (int)(relativeMousePosY / scaleY), stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_button_down(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseButtonDown)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->onMouseButtonDown(pElement, mouseButton, (int)(relativeMousePosX / scaleX), (int)(relativeMousePosY / scaleY), stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_button_up(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseButtonUp)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->onMouseButtonUp(pElement, mouseButton, (int)(relativeMousePosX / scaleX), (int)(relativeMousePosY / scaleY), stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_button_dblclick(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseButtonDblClick)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->onMouseButtonDblClick(pElement, mouseButton, (int)(relativeMousePosX / scaleX), (int)(relativeMousePosY / scaleY), stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_mouse_wheel(drgui_element* pElement, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onMouseWheel)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->onMouseWheel(pElement, delta, (int)(relativeMousePosX / scaleX), (int)(relativeMousePosY / scaleY), stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_key_down(drgui_element* pElement, drgui_key key, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onKeyDown) {
            pElement->onKeyDown(pElement, key, stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_key_up(drgui_element* pElement, drgui_key key, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onKeyUp) {
            pElement->onKeyUp(pElement, key, stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}

void drgui_post_outbound_event_printable_key_down(drgui_element* pElement, unsigned int character, int stateFlags)
{
    if (drgui_begin_outbound_event(pElement))
    {
        if (pElement->onPrintableKeyDown) {
            pElement->onPrintableKeyDown(pElement, character, stateFlags);
        }

        drgui_end_outbound_event(pElement);
    }
}


void drgui_post_outbound_event_dirty(drgui_element* pElement, drgui_rect relativeRect)
{
    if (pElement != NULL)
    {
        if (pElement->onDirty) {
            pElement->onDirty(pElement, relativeRect);
        }
    }
}

void drgui_post_outbound_event_dirty_global(drgui_element* pElement, drgui_rect relativeRect)
{
    if (pElement != NULL && pElement->pContext != NULL)
    {
        if (pElement->pContext->onGlobalDirty)
        {
            float scaleX;
            float scaleY;
            drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

            pElement->pContext->onGlobalDirty(pElement, drgui_scale_rect(relativeRect, scaleX, scaleY));
        }
    }
}

void drgui_post_outbound_event_capture_mouse(drgui_element* pElement)
{
    if (pElement != NULL)
    {
        if (pElement->onCaptureMouse) {
            pElement->onCaptureMouse(pElement);
        }
    }
}

void drgui_post_outbound_event_capture_mouse_global(drgui_element* pElement)
{
    if (pElement != NULL && pElement->pContext != NULL)
    {
        if (pElement->pContext->onGlobalCaptureMouse) {
            pElement->pContext->onGlobalCaptureMouse(pElement);
        }
    }
}

void drgui_post_outbound_event_release_mouse(drgui_element* pElement)
{
    if (pElement != NULL)
    {
        if (pElement->onReleaseMouse) {
            pElement->onReleaseMouse(pElement);
        }
    }
}

void drgui_post_outbound_event_release_mouse_global(drgui_element* pElement)
{
    if (pElement != NULL && pElement->pContext != NULL)
    {
        if (pElement->pContext->onGlobalReleaseMouse) {
            pElement->pContext->onGlobalReleaseMouse(pElement);
        }
    }
}


void drgui_post_outbound_event_capture_keyboard(drgui_element* pElement, drgui_element* pPrevCapturedElement)
{
    if (pElement != NULL)
    {
        if (pElement->onCaptureKeyboard) {
            pElement->onCaptureKeyboard(pElement, pPrevCapturedElement);
        }
    }
}

void drgui_post_outbound_event_capture_keyboard_global(drgui_element* pElement, drgui_element* pPrevCapturedElement)
{
    if (pElement != NULL && pElement->pContext != NULL)
    {
        if (pElement->pContext->onGlobalCaptureKeyboard) {
            pElement->pContext->onGlobalCaptureKeyboard(pElement, pPrevCapturedElement);
        }
    }
}

void drgui_post_outbound_event_release_keyboard(drgui_element* pElement, drgui_element* pNewCapturedElement)
{
    if (pElement != NULL)
    {
        if (pElement->onReleaseKeyboard) {
            pElement->onReleaseKeyboard(pElement, pNewCapturedElement);
        }
    }
}

void drgui_post_outbound_event_release_keyboard_global(drgui_element* pElement, drgui_element* pNewCapturedElement)
{
    if (pElement != NULL && pElement->pContext != NULL)
    {
        if (pElement->pContext->onGlobalReleaseKeyboard) {
            pElement->pContext->onGlobalReleaseKeyboard(pElement, pNewCapturedElement);
        }
    }
}


void drgui_log(drgui_context* pContext, const char* message)
{
    if (pContext != NULL)
    {
        if (pContext->onLog) {
            pContext->onLog(pContext, message);
        }
    }
}


DRGUI_PRIVATE drgui_resource drgui_get_internal_font_by_scale(drgui_font* pFont, float scaleY)
{
    assert(pFont != NULL);
    assert(pFont->pContext != NULL);

    if (pFont->pContext->paintingCallbacks.getFontSize == NULL)
    {
        if (pFont->internalFontCount == 0) {
            return NULL;
        }

        return pFont->pInternalFonts[0];
    }


    // First check to see if a font of the appropriate size has already been created.
    unsigned int targetSize = (unsigned int)(pFont->size * scaleY);
    if (targetSize == 0) {
        targetSize = 1;
    }

    for (unsigned int i = 0; i < pFont->internalFontCount; ++i)
    {
        if (pFont->pContext->paintingCallbacks.getFontSize(pFont->pInternalFonts[i]) == targetSize) {
            return pFont->pInternalFonts[i];
        }
    }


    // At this point we know that a font of the appropriate size has not yet been loaded, so we need to try and load it now.
    if (pFont->pContext->paintingCallbacks.createFont == NULL) {
        return NULL;
    }

    drgui_resource internalFont = pFont->pContext->paintingCallbacks.createFont(pFont->pContext->pPaintingContext, pFont->family, targetSize, pFont->weight, pFont->slant, pFont->rotation);
    if (internalFont == NULL) {
        return NULL;
    }

    drgui_resource* pOldInternalFonts = pFont->pInternalFonts;
    drgui_resource* pNewInternalFonts = malloc(sizeof(*pNewInternalFonts) * (pFont->internalFontCount + 1));

    for (size_t i = 0; i < pFont->internalFontCount; ++i) {
        pNewInternalFonts[i] = pOldInternalFonts[i];
    }
    pNewInternalFonts[pFont->internalFontCount] = internalFont;

    pFont->pInternalFonts     = pNewInternalFonts;
    pFont->internalFontCount += 1;


    free(pOldInternalFonts);
    return internalFont;
}


/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

drgui_context* drgui_create_context()
{
    drgui_context* pContext = malloc(sizeof(drgui_context));
    if (pContext != NULL) {
        pContext->pPaintingContext                           = NULL;
        pContext->paintingCallbacks.drawBegin                = NULL;
        pContext->paintingCallbacks.drawEnd                  = NULL;
        pContext->paintingCallbacks.setClip                  = NULL;
        pContext->paintingCallbacks.getClip                  = NULL;
        pContext->paintingCallbacks.drawLine                 = NULL;
        pContext->paintingCallbacks.drawRect                 = NULL;
        pContext->paintingCallbacks.drawRectOutline          = NULL;
        pContext->paintingCallbacks.drawRectWithOutline      = NULL;
        pContext->paintingCallbacks.drawRoundRect            = NULL;
        pContext->paintingCallbacks.drawRoundRectOutline     = NULL;
        pContext->paintingCallbacks.drawRoundRectWithOutline = NULL;
        pContext->paintingCallbacks.drawText                 = NULL;
        pContext->paintingCallbacks.drawImage                = NULL;
        pContext->paintingCallbacks.createFont               = NULL;
        pContext->paintingCallbacks.deleteFont               = NULL;
        pContext->paintingCallbacks.getFontSize              = NULL;
        pContext->paintingCallbacks.getFontMetrics           = NULL;
        pContext->paintingCallbacks.getGlyphMetrics          = NULL;
        pContext->paintingCallbacks.measureString            = NULL;
        pContext->paintingCallbacks.createImage              = NULL;
        pContext->paintingCallbacks.deleteImage              = NULL;
        pContext->paintingCallbacks.getImageSize             = NULL;
        pContext->inboundEventCounter                        = 0;
        pContext->outboundEventLockCounter                   = 0;
        pContext->pFirstDeadElement                          = NULL;
        pContext->pElementUnderMouse                         = NULL;
        pContext->pElementWithMouseCapture                   = NULL;
        pContext->pElementWithKeyboardCapture                = NULL;
        pContext->pElementWantingKeyboardCapture             = NULL;
        pContext->currentCursor                              = drgui_cursor_default;
        pContext->flags                                      = 0;
        pContext->onGlobalDirty                              = NULL;
        pContext->onGlobalCaptureMouse                       = NULL;
        pContext->onGlobalReleaseMouse                       = NULL;
        pContext->onGlobalCaptureKeyboard                    = NULL;
        pContext->onGlobalReleaseKeyboard                    = NULL;
        pContext->onChangeCursor                             = NULL;
        pContext->onLog                                      = NULL;
        pContext->pLastMouseMoveTopLevelElement              = NULL;
        pContext->lastMouseMovePosX                          = 0;
        pContext->lastMouseMovePosY                          = 0;
        pContext->pDirtyTopLevelElement                      = NULL;
        pContext->dirtyRect                                  = drgui_make_inside_out_rect();
        pContext->dirtyCounter                               = 0;
    }

    return pContext;
}

void drgui_delete_context(drgui_context* pContext)
{
    if (pContext == NULL) {
        return;
    }


    // Make sure the mouse capture is released.
    if (pContext->pElementWithMouseCapture != NULL)
    {
        drgui_log(pContext, "WARNING: Deleting the GUI context while an element still has the mouse capture.");
        drgui_release_mouse(pContext);
    }

    // Make sure the keyboard capture is released.
    if (pContext->pElementWithKeyboardCapture != NULL)
    {
        drgui_log(pContext, "WARNING: Deleting the GUI context while an element still has the keyboard capture.");
        drgui_release_keyboard(pContext);
    }


    if (drgui_is_handling_inbound_event(pContext))
    {
        // An inbound event is still being processed - we don't want to delete the context straight away because we can't
        // trust external event handlers to not try to access the context later on. To do this we just set the flag that
        // the context is deleted. It will then be deleted for real at the end of the inbound event handler.
        drgui_mark_context_as_dead(pContext);
    }
    else
    {
        // An inbound event is not being processed, so delete the context straight away.
        drgui_delete_context_for_real(pContext);
    }
}



/////////////////////////////////////////////////////////////////
// Events

void drgui_post_inbound_event_mouse_leave(drgui_element* pTopLevelElement)
{
    if (pTopLevelElement == NULL) {
        return;
    }

    drgui_context* pContext = pTopLevelElement->pContext;
    if (pContext == NULL) {
        return;
    }

    drgui_begin_inbound_event(pContext);
    {
        // We assume that was previously under the mouse was either pTopLevelElement itself or one of it's descendants.
        drgui_update_mouse_enter_and_leave_state(pContext, NULL);
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_mouse_move(drgui_element* pTopLevelElement, int mousePosX, int mousePosY, int stateFlags)
{
    if (pTopLevelElement == NULL || pTopLevelElement->pContext == NULL) {
        return;
    }


    drgui_begin_inbound_event(pTopLevelElement->pContext);
    {
        /// A pointer to the top level element that was passed in from the last inbound mouse move event.
        pTopLevelElement->pContext->pLastMouseMoveTopLevelElement = pTopLevelElement;

        /// The position of the mouse that was passed in from the last inbound mouse move event.
        pTopLevelElement->pContext->lastMouseMovePosX = (float)mousePosX;
        pTopLevelElement->pContext->lastMouseMovePosY = (float)mousePosY;



        // The first thing we need to do is find the new element that's sitting under the mouse.
        drgui_element* pNewElementUnderMouse = drgui_find_element_under_point(pTopLevelElement, (float)mousePosX, (float)mousePosY);

        // Now that we know which element is sitting under the mouse we need to check if the mouse has entered into a new element.
        drgui_update_mouse_enter_and_leave_state(pTopLevelElement->pContext, pNewElementUnderMouse);


        drgui_element* pEventReceiver = pTopLevelElement->pContext->pElementWithMouseCapture;
        if (pEventReceiver == NULL)
        {
            pEventReceiver = pNewElementUnderMouse;
        }

        if (pEventReceiver != NULL)
        {
            float relativeMousePosX = (float)mousePosX;
            float relativeMousePosY = (float)mousePosY;
            drgui_make_point_relative(pEventReceiver, &relativeMousePosX, &relativeMousePosY);

            drgui_post_outbound_event_mouse_move(pEventReceiver, (int)relativeMousePosX, (int)relativeMousePosY, stateFlags);
        }
    }
    drgui_end_inbound_event(pTopLevelElement->pContext);
}

void drgui_post_inbound_event_mouse_button_down(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags)
{
    if (pTopLevelElement == NULL || pTopLevelElement->pContext == NULL) {
        return;
    }

    drgui_context* pContext = pTopLevelElement->pContext;
    drgui_begin_inbound_event(pContext);
    {
        drgui_element* pEventReceiver = pContext->pElementWithMouseCapture;
        if (pEventReceiver == NULL)
        {
            pEventReceiver = pContext->pElementUnderMouse;

            if (pEventReceiver == NULL)
            {
                // We'll get here if this message is posted without a prior mouse move event.
                pEventReceiver = drgui_find_element_under_point(pTopLevelElement, (float)mousePosX, (float)mousePosY);
            }
        }


        if (pEventReceiver != NULL)
        {
            float relativeMousePosX = (float)mousePosX;
            float relativeMousePosY = (float)mousePosY;
            drgui_make_point_relative(pEventReceiver, &relativeMousePosX, &relativeMousePosY);

            drgui_post_outbound_event_mouse_button_down(pEventReceiver, mouseButton, (int)relativeMousePosX, (int)relativeMousePosY, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_mouse_button_up(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags)
{
    if (pTopLevelElement == NULL || pTopLevelElement->pContext == NULL) {
        return;
    }

    drgui_context* pContext = pTopLevelElement->pContext;
    drgui_begin_inbound_event(pContext);
    {
        drgui_element* pEventReceiver = pContext->pElementWithMouseCapture;
        if (pEventReceiver == NULL)
        {
            pEventReceiver = pContext->pElementUnderMouse;

            if (pEventReceiver == NULL)
            {
                // We'll get here if this message is posted without a prior mouse move event.
                pEventReceiver = drgui_find_element_under_point(pTopLevelElement, (float)mousePosX, (float)mousePosY);
            }
        }


        if (pEventReceiver != NULL)
        {
            float relativeMousePosX = (float)mousePosX;
            float relativeMousePosY = (float)mousePosY;
            drgui_make_point_relative(pEventReceiver, &relativeMousePosX, &relativeMousePosY);

            drgui_post_outbound_event_mouse_button_up(pEventReceiver, mouseButton, (int)relativeMousePosX, (int)relativeMousePosY, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_mouse_button_dblclick(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags)
{
    if (pTopLevelElement == NULL || pTopLevelElement->pContext == NULL) {
        return;
    }

    drgui_context* pContext = pTopLevelElement->pContext;
    drgui_begin_inbound_event(pContext);
    {
        drgui_element* pEventReceiver = pContext->pElementWithMouseCapture;
        if (pEventReceiver == NULL)
        {
            pEventReceiver = pContext->pElementUnderMouse;

            if (pEventReceiver == NULL)
            {
                // We'll get here if this message is posted without a prior mouse move event.
                pEventReceiver = drgui_find_element_under_point(pTopLevelElement, (float)mousePosX, (float)mousePosY);
            }
        }


        if (pEventReceiver != NULL)
        {
            float relativeMousePosX = (float)mousePosX;
            float relativeMousePosY = (float)mousePosY;
            drgui_make_point_relative(pEventReceiver, &relativeMousePosX, &relativeMousePosY);

            drgui_post_outbound_event_mouse_button_dblclick(pEventReceiver, mouseButton, (int)relativeMousePosX, (int)relativeMousePosY, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_mouse_wheel(drgui_element* pTopLevelElement, int delta, int mousePosX, int mousePosY, int stateFlags)
{
    if (pTopLevelElement == NULL || pTopLevelElement->pContext == NULL) {
        return;
    }

    drgui_context* pContext = pTopLevelElement->pContext;
    drgui_begin_inbound_event(pContext);
    {
        drgui_element* pEventReceiver = pContext->pElementWithMouseCapture;
        if (pEventReceiver == NULL)
        {
            pEventReceiver = pContext->pElementUnderMouse;

            if (pEventReceiver == NULL)
            {
                // We'll get here if this message is posted without a prior mouse move event.
                pEventReceiver = drgui_find_element_under_point(pTopLevelElement, (float)mousePosX, (float)mousePosY);
            }
        }


        if (pEventReceiver != NULL)
        {
            float relativeMousePosX = (float)mousePosX;
            float relativeMousePosY = (float)mousePosY;
            drgui_make_point_relative(pEventReceiver, &relativeMousePosX, &relativeMousePosY);

            drgui_post_outbound_event_mouse_wheel(pEventReceiver, delta, (int)relativeMousePosX, (int)relativeMousePosY, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_key_down(drgui_context* pContext, drgui_key key, int stateFlags)
{
    if (pContext == NULL) {
        return;
    }

    drgui_begin_inbound_event(pContext);
    {
        if (pContext->pElementWithKeyboardCapture != NULL) {
            drgui_post_outbound_event_key_down(pContext->pElementWithKeyboardCapture, key, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_key_up(drgui_context* pContext, drgui_key key, int stateFlags)
{
    if (pContext == NULL) {
        return;
    }

    drgui_begin_inbound_event(pContext);
    {
        if (pContext->pElementWithKeyboardCapture != NULL) {
            drgui_post_outbound_event_key_up(pContext->pElementWithKeyboardCapture, key, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}

void drgui_post_inbound_event_printable_key_down(drgui_context* pContext, unsigned int character, int stateFlags)
{
    if (pContext == NULL) {
        return;
    }

    drgui_begin_inbound_event(pContext);
    {
        if (pContext->pElementWithKeyboardCapture != NULL) {
            drgui_post_outbound_event_printable_key_down(pContext->pElementWithKeyboardCapture, character, stateFlags);
        }
    }
    drgui_end_inbound_event(pContext);
}



void drgui_set_global_on_dirty(drgui_context * pContext, drgui_on_dirty_proc onDirty)
{
    if (pContext != NULL) {
        pContext->onGlobalDirty = onDirty;
    }
}

void drgui_set_global_on_capture_mouse(drgui_context* pContext, drgui_on_capture_mouse_proc onCaptureMouse)
{
    if (pContext != NULL) {
        pContext->onGlobalCaptureMouse = onCaptureMouse;
    }
}

void drgui_set_global_on_release_mouse(drgui_context* pContext, drgui_on_release_mouse_proc onReleaseMouse)
{
    if (pContext != NULL) {
        pContext->onGlobalReleaseMouse = onReleaseMouse;
    }
}

void drgui_set_global_on_capture_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onCaptureKeyboard)
{
    if (pContext != NULL) {
        pContext->onGlobalCaptureKeyboard = onCaptureKeyboard;
    }
}

void drgui_set_global_on_release_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onReleaseKeyboard)
{
    if (pContext != NULL) {
        pContext->onGlobalReleaseKeyboard = onReleaseKeyboard;
    }
}

void drgui_set_global_on_change_cursor(drgui_context* pContext, drgui_on_change_cursor_proc onChangeCursor)
{
    if (pContext != NULL) {
        pContext->onChangeCursor = onChangeCursor;
    }
}

void drgui_set_on_log(drgui_context* pContext, drgui_on_log onLog)
{
    if (pContext != NULL) {
        pContext->onLog = onLog;
    }
}



/////////////////////////////////////////////////////////////////
// Elements

drgui_element* drgui_create_element(drgui_context* pContext, drgui_element* pParent, size_t extraDataSize, const void* pExtraData)
{
    if (pContext != NULL)
    {
        drgui_element* pElement = (drgui_element*)malloc(sizeof(drgui_element) - sizeof(pElement->pExtraData) + extraDataSize);
        if (pElement != NULL)
        {
            pElement->pContext              = pContext;
            pElement->pParent               = pParent;
            pElement->pFirstChild           = NULL;
            pElement->pLastChild            = NULL;
            pElement->pNextSibling          = NULL;
            pElement->pPrevSibling          = NULL;
            pElement->pNextDeadElement      = NULL;
            pElement->absolutePosX          = 0;
            pElement->absolutePosY          = 0;
            pElement->width                 = 0;
            pElement->height                = 0;
            pElement->innerScaleX           = 1;
            pElement->innerScaleY           = 1;
            pElement->cursor                = drgui_cursor_default;
            pElement->flags                 = 0;
            pElement->onMove                = NULL;
            pElement->onSize                = NULL;
            pElement->onMouseEnter          = NULL;
            pElement->onMouseLeave          = NULL;
            pElement->onMouseMove           = NULL;
            pElement->onMouseButtonDown     = NULL;
            pElement->onMouseButtonUp       = NULL;
            pElement->onMouseButtonDblClick = NULL;
            pElement->onMouseWheel          = NULL;
            pElement->onKeyDown             = NULL;
            pElement->onKeyUp               = NULL;
            pElement->onPrintableKeyDown    = NULL;
            pElement->onPaint               = NULL;
            pElement->onDirty               = NULL;
            pElement->onHitTest             = NULL;
            pElement->onCaptureMouse        = NULL;
            pElement->onReleaseMouse        = NULL;
            pElement->onCaptureKeyboard     = NULL;
            pElement->onReleaseKeyboard     = NULL;

            pElement->extraDataSize = extraDataSize;
            if (pExtraData != NULL) {
                memcpy(pElement->pExtraData, pExtraData, extraDataSize);
            }

            // Add to the the hierarchy.
            drgui_append_without_detach_or_redraw(pElement, pElement->pParent);


            // Have the element positioned at 0,0 relative to the parent by default.
            if (pParent != NULL) {
                pElement->absolutePosX = pParent->absolutePosX;
                pElement->absolutePosY = pParent->absolutePosY;
            }


            return pElement;
        }
    }

    return NULL;
}

void drgui_delete_element(drgui_element* pElement)
{
    if (pElement == NULL) {
        return;
    }

    drgui_context* pContext = pElement->pContext;
    if (pContext == NULL) {
        return;
    }

    if (drgui_is_element_marked_as_dead(pElement)) {
        drgui_log(pContext, "WARNING: Attempting to delete an element that is already marked for deletion.");
        return;
    }




    // Orphan the element first.
    drgui_detach_without_redraw(pElement);


    // If this was element is marked as the one that was last under the mouse it needs to be unset.
    bool needsMouseUpdate = false;
    if (pContext->pElementUnderMouse == pElement)
    {
        pContext->pElementUnderMouse = NULL;
        needsMouseUpdate = true;
    }

    if (pContext->pLastMouseMoveTopLevelElement == pElement)
    {
        pContext->pLastMouseMoveTopLevelElement = NULL;
        pContext->lastMouseMovePosX = 0;
        pContext->lastMouseMovePosY = 0;
        needsMouseUpdate = false;       // It was a top-level element so the mouse enter/leave state doesn't need an update.
    }


    // If this element has the mouse capture it needs to be released.
    if (pContext->pElementWithMouseCapture == pElement)
    {
        drgui_log(pContext, "WARNING: Deleting an element while it still has the mouse capture.");
        drgui_release_mouse(pContext);
    }

    // If this element has the keyboard capture it needs to be released.
    if (pContext->pElementWithKeyboardCapture == pElement)
    {
        drgui_log(pContext, "WARNING: Deleting an element while it still has the keyboard capture.");
        drgui_release_keyboard(pContext);
    }

    // Is this element in the middle of being marked as dirty?
    if (pContext->pDirtyTopLevelElement == pElement)
    {
        drgui_log(pContext, "WARNING: Deleting an element while it is being marked as dirty.");
        pContext->pDirtyTopLevelElement = NULL;
    }



    // Deleting this element may have resulted in the mouse entering a new element. Here is where we do a mouse enter/leave update.
    if (needsMouseUpdate)
    {
        pElement->onHitTest = drgui_pass_through_hit_test;        // <-- This ensures we don't include this element when searching for the new element under the mouse.
        drgui_update_mouse_enter_and_leave_state(pContext, drgui_find_element_under_point(pContext->pLastMouseMoveTopLevelElement, pContext->lastMouseMovePosX, pContext->lastMouseMovePosY));
    }



    // Children need to be deleted before deleting the element itself.
    while (pElement->pLastChild != NULL)
    {
        drgui_delete_element(pElement->pLastChild);
    }



    // Finally, we either need to mark the element as dead or delete it for real. We only mark it for deletion if we are in the middle
    // of processing an inbound event because there is a chance that an external event handler may try referencing the element.
    if (drgui_is_handling_inbound_event(pContext))
    {
        drgui_mark_element_as_dead(pElement);
    }
    else
    {
        drgui_delete_element_for_real(pElement);
    }
}


size_t drgui_get_extra_data_size(drgui_element* pElement)
{
    if (pElement != NULL) {
        return pElement->extraDataSize;
    }

    return 0;
}

void* drgui_get_extra_data(drgui_element* pElement)
{
    if (pElement != NULL) {
        return pElement->pExtraData;
    }

    return NULL;
}


bool drgui_set_type(drgui_element* pElement, const char* type)
{
    if (pElement == NULL) {
        return false;
    }

    return drgui__strcpy_s(pElement->type, sizeof(pElement->type), (type == NULL) ? "" : type) == 0;
}

const char* drgui_get_type(drgui_element* pElement)
{
    if (pElement == NULL) {
        return NULL;
    }

    return pElement->type;
}

bool drgui_is_of_type(drgui_element* pElement, const char* type)
{
    if (pElement == NULL) {
        return false;
    }

    return strncmp(pElement->type, type, strlen(type)) == 0;
}


void drgui_hide(drgui_element* pElement)
{
    if (pElement != NULL) {
        pElement->flags |= IS_ELEMENT_HIDDEN;
        drgui_auto_dirty(pElement, drgui_get_local_rect(pElement));
    }
}

void drgui_show(drgui_element* pElement)
{
    if (pElement != NULL) {
        pElement->flags &= ~IS_ELEMENT_HIDDEN;
        drgui_auto_dirty(pElement, drgui_get_local_rect(pElement));
    }
}

bool drgui_is_visible(const drgui_element* pElement)
{
    if (pElement != NULL) {
        return (pElement->flags & IS_ELEMENT_HIDDEN) == 0;
    }

    return false;
}

bool drgui_is_visible_recursive(const drgui_element* pElement)
{
    if (drgui_is_visible(pElement))
    {
        assert(pElement->pParent != NULL);

        if (pElement->pParent != NULL) {
            return drgui_is_visible(pElement->pParent);
        }
    }

    return false;
}


void drgui_disable_clipping(drgui_element* pElement)
{
    if (pElement != NULL) {
        pElement->flags |= IS_ELEMENT_CLIPPING_DISABLED;
    }
}

void drgui_enable_clipping(drgui_element* pElement)
{
    if (pElement != NULL) {
        pElement->flags &= ~IS_ELEMENT_CLIPPING_DISABLED;
    }
}

bool drgui_is_clipping_enabled(const drgui_element* pElement)
{
    if (pElement != NULL) {
        return (pElement->flags & IS_ELEMENT_CLIPPING_DISABLED) == 0;
    }

    return true;
}



void drgui_capture_mouse(drgui_element* pElement)
{
    if (pElement == NULL) {
        return;
    }

    if (pElement->pContext == NULL) {
        return;
    }


    if (pElement->pContext->pElementWithMouseCapture != pElement)
    {
        // Release the previous capture first.
        if (pElement->pContext->pElementWithMouseCapture != NULL) {
            drgui_release_mouse(pElement->pContext);
        }

        assert(pElement->pContext->pElementWithMouseCapture == NULL);

        pElement->pContext->pElementWithMouseCapture = pElement;

        // Two events need to be posted - the global on_capture_mouse event and the local on_capture_mouse event.
        drgui_post_outbound_event_capture_mouse(pElement);
        drgui_post_outbound_event_capture_mouse_global(pElement);
    }
}

void drgui_release_mouse(drgui_context* pContext)
{
    if (pContext == NULL) {
        return;
    }


    // Events need to be posted before setting the internal pointer.
    drgui_post_outbound_event_release_mouse(pContext->pElementWithMouseCapture);
    drgui_post_outbound_event_release_mouse_global(pContext->pElementWithMouseCapture);

    // We want to set the internal pointer to NULL after posting the events since that is when it has truly released the mouse.
    pContext->pElementWithMouseCapture = NULL;


    // After releasing the mouse the cursor may be sitting on top of a different element - we want to recheck that.
    drgui_update_mouse_enter_and_leave_state(pContext, drgui_find_element_under_point(pContext->pLastMouseMoveTopLevelElement, pContext->lastMouseMovePosX, pContext->lastMouseMovePosY));
}

drgui_element* drgui_get_element_with_mouse_capture(drgui_context* pContext)
{
    if (pContext == NULL) {
        return NULL;
    }

    return pContext->pElementWithMouseCapture;
}


DRGUI_PRIVATE void drgui_release_keyboard_private(drgui_context* pContext, drgui_element* pNewCapturedElement)
{
    assert(pContext != NULL);

    // It is reasonable to expect that an application will want to change keyboard focus from within the release_keyboard
    // event handler. The problem with this is that is can cause a infinite dependency chain. We need to handle that case
    // by setting a flag that keeps track of whether or not we are in the middle of a release_keyboard event. At the end
    // we look at the element that want's the keyboard focuse and explicitly capture it at the end.

    pContext->flags |= IS_RELEASING_KEYBOARD;
    {
        drgui_element* pPrevCapturedElement = pContext->pElementWithKeyboardCapture;
        pContext->pElementWithKeyboardCapture = NULL;

        drgui_post_outbound_event_release_keyboard(pPrevCapturedElement, pNewCapturedElement);
        drgui_post_outbound_event_release_keyboard_global(pPrevCapturedElement, pNewCapturedElement);
    }
    pContext->flags &= ~IS_RELEASING_KEYBOARD;

    // Explicitly capture the keyboard.
    drgui_capture_keyboard(pContext->pElementWantingKeyboardCapture);
    pContext->pElementWantingKeyboardCapture = NULL;
}

void drgui_capture_keyboard(drgui_element* pElement)
{
    if (pElement == NULL) {
        return;
    }

    if (pElement->pContext == NULL) {
        return;
    }


    if ((pElement->pContext->flags & IS_RELEASING_KEYBOARD) != 0) {
        pElement->pContext->pElementWantingKeyboardCapture = pElement;
        return;
    }


    if (pElement->pContext->pElementWithKeyboardCapture != pElement)
    {
        // Release the previous capture first.
        drgui_element* pPrevElementWithKeyboardCapture = pElement->pContext->pElementWithKeyboardCapture;
        if (pPrevElementWithKeyboardCapture != NULL) {
            drgui_release_keyboard_private(pElement->pContext, pElement);
        }

        assert(pElement->pContext->pElementWithKeyboardCapture == NULL);

        pElement->pContext->pElementWithKeyboardCapture = pElement;

        // Two events need to be posted - the global on_capture_mouse event and the local on_capture_mouse event.
        drgui_post_outbound_event_capture_keyboard(pElement, pPrevElementWithKeyboardCapture);
        drgui_post_outbound_event_capture_keyboard_global(pElement, pPrevElementWithKeyboardCapture);
    }
}

void drgui_release_keyboard(drgui_context* pContext)
{
    if (pContext == NULL) {
        return;
    }

    drgui_release_keyboard_private(pContext, NULL);
}

drgui_element* drgui_get_element_with_keyboard_capture(drgui_context* pContext)
{
    if (pContext == NULL) {
        return NULL;
    }

    return pContext->pElementWithKeyboardCapture;
}


void drgui_set_cursor(drgui_element* pElement, drgui_cursor_type cursor)
{
    if (pElement == NULL) {
        return;
    }

    pElement->cursor = cursor;

    if (drgui_is_element_under_mouse(pElement) && pElement->pContext->currentCursor != cursor) {
        drgui__change_cursor(pElement, cursor);
    }
}

drgui_cursor_type drgui_get_cursor(drgui_element* pElement)
{
    if (pElement == NULL) {
        return drgui_cursor_none;
    }

    return pElement->cursor;
}



//// Events ////

void drgui_set_on_move(drgui_element * pElement, drgui_on_move_proc callback)
{
    if (pElement != NULL) {
        pElement->onMove = callback;
    }
}

void drgui_set_on_size(drgui_element * pElement, drgui_on_size_proc callback)
{
    if (pElement != NULL) {
        pElement->onSize = callback;
    }
}

void drgui_set_on_mouse_enter(drgui_element* pElement, drgui_on_mouse_enter_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseEnter = callback;
    }
}

void drgui_set_on_mouse_leave(drgui_element* pElement, drgui_on_mouse_leave_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseLeave = callback;
    }
}

void drgui_set_on_mouse_move(drgui_element* pElement, drgui_on_mouse_move_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseMove = callback;
    }
}

void drgui_set_on_mouse_button_down(drgui_element* pElement, drgui_on_mouse_button_down_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseButtonDown = callback;
    }
}

void drgui_set_on_mouse_button_up(drgui_element* pElement, drgui_on_mouse_button_up_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseButtonUp = callback;
    }
}

void drgui_set_on_mouse_button_dblclick(drgui_element* pElement, drgui_on_mouse_button_dblclick_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseButtonDblClick = callback;
    }
}

void drgui_set_on_mouse_wheel(drgui_element* pElement, drgui_on_mouse_wheel_proc callback)
{
    if (pElement != NULL) {
        pElement->onMouseWheel = callback;
    }
}

void drgui_set_on_key_down(drgui_element* pElement, drgui_on_key_down_proc callback)
{
    if (pElement != NULL) {
        pElement->onKeyDown = callback;
    }
}

void drgui_set_on_key_up(drgui_element* pElement, drgui_on_key_up_proc callback)
{
    if (pElement != NULL) {
        pElement->onKeyUp = callback;
    }
}

void drgui_set_on_printable_key_down(drgui_element* pElement, drgui_on_printable_key_down_proc callback)
{
    if (pElement != NULL) {
        pElement->onPrintableKeyDown = callback;
    }
}

void drgui_set_on_paint(drgui_element* pElement, drgui_on_paint_proc callback)
{
    if (pElement != NULL) {
        pElement->onPaint = callback;
    }
}

void drgui_set_on_dirty(drgui_element * pElement, drgui_on_dirty_proc callback)
{
    if (pElement != NULL) {
        pElement->onDirty = callback;
    }
}

void drgui_set_on_hittest(drgui_element* pElement, drgui_on_hittest_proc callback)
{
    if (pElement != NULL) {
        pElement->onHitTest = callback;
    }
}

void drgui_set_on_capture_mouse(drgui_element* pElement, drgui_on_capture_mouse_proc callback)
{
    if (pElement != NULL) {
        pElement->onCaptureMouse = callback;
    }
}

void drgui_set_on_release_mouse(drgui_element* pElement, drgui_on_release_mouse_proc callback)
{
    if (pElement != NULL) {
        pElement->onReleaseMouse = callback;
    }
}

void drgui_set_on_capture_keyboard(drgui_element* pElement, drgui_on_capture_keyboard_proc callback)
{
    if (pElement != NULL) {
        pElement->onCaptureKeyboard = callback;
    }
}

void drgui_set_on_release_keyboard(drgui_element* pElement, drgui_on_release_keyboard_proc callback)
{
    if (pElement != NULL) {
        pElement->onReleaseKeyboard = callback;
    }
}



bool drgui_is_point_inside_element_bounds(const drgui_element* pElement, float absolutePosX, float absolutePosY)
{
    if (absolutePosX < pElement->absolutePosX ||
        absolutePosX < pElement->absolutePosY)
    {
        return false;
    }

    if (absolutePosX >= pElement->absolutePosX + pElement->width ||
        absolutePosY >= pElement->absolutePosY + pElement->height)
    {
        return false;
    }

    return true;
}

bool drgui_is_point_inside_element(drgui_element* pElement, float absolutePosX, float absolutePosY)
{
    if (drgui_is_point_inside_element_bounds(pElement, absolutePosX, absolutePosY))
    {
        // It is valid for onHitTest to be null, in which case we use the default hit test which assumes the element is just a rectangle
        // equal to the size of it's bounds. It's equivalent to onHitTest always returning true.

        if (pElement->onHitTest) {
            return pElement->onHitTest(pElement, absolutePosX - pElement->absolutePosX, absolutePosY - pElement->absolutePosY);
        }

        return true;
    }

    return false;
}



typedef struct
{
    drgui_element* pElementUnderPoint;
    float absolutePosX;
    float absolutePosY;
}drgui_find_element_under_point_data;

bool drgui_find_element_under_point_iterator(drgui_element* pElement, drgui_rect* pRelativeVisibleRect, void* pUserData)
{
    assert(pElement             != NULL);
    assert(pRelativeVisibleRect != NULL);

    drgui_find_element_under_point_data* pData = pUserData;
    assert(pData != NULL);

    float innerScaleX;
    float innerScaleY;
    drgui_get_absolute_inner_scale(pElement->pParent, &innerScaleX, &innerScaleY);

    float relativePosX = pData->absolutePosX / innerScaleX;
    float relativePosY = pData->absolutePosY / innerScaleY;
    drgui_make_point_relative(pElement, &relativePosX, &relativePosY);

    if (drgui_rect_contains_point(*pRelativeVisibleRect, relativePosX, relativePosY))
    {
        if (pElement->onHitTest) {
            if (pElement->onHitTest(pElement, relativePosX, relativePosY)) {
                pData->pElementUnderPoint = pElement;
            }
        } else {
            pData->pElementUnderPoint = pElement;
        }
    }


    // Always return true to ensure the entire hierarchy is checked.
    return true;
}

drgui_element* drgui_find_element_under_point(drgui_element* pTopLevelElement, float absolutePosX, float absolutePosY)
{
    if (pTopLevelElement == NULL) {
        return NULL;
    }

    drgui_find_element_under_point_data data;
    data.pElementUnderPoint = NULL;
    data.absolutePosX = absolutePosX;
    data.absolutePosY = absolutePosY;
    drgui_iterate_visible_elements(pTopLevelElement, drgui_get_absolute_rect(pTopLevelElement), drgui_find_element_under_point_iterator, &data);

    return data.pElementUnderPoint;
}

bool drgui_is_element_under_mouse(drgui_element* pElement)
{
    if (pElement == NULL) {
        return false;
    }

    return drgui_find_element_under_point(pElement->pContext->pLastMouseMoveTopLevelElement, pElement->pContext->lastMouseMovePosX, pElement->pContext->lastMouseMovePosY);
}



//// Hierarchy ////

void drgui_detach(drgui_element* pChildElement)
{
    if (pChildElement == NULL) {
        return;
    }

    drgui_element* pOldParent = pChildElement->pParent;


    // We orphan the element using the private API. This will not mark the parent element as dirty so we need to do that afterwards.
    drgui_detach_without_redraw(pChildElement);

    // The region of the old parent needs to be redrawn.
    if (pOldParent != NULL) {
        drgui_auto_dirty(pOldParent, drgui_get_relative_rect(pOldParent));
    }
}

void drgui_append(drgui_element* pChildElement, drgui_element* pParentElement)
{
    if (pChildElement == NULL) {
        return;
    }

    // We first need to orphan the element. If the parent element is the new parent is the same as the old one, as in we
    // are just moving the child element to the end of the children list, we want to delay the repaint until the end. To
    // do this we use drgui_detach_without_redraw() because that will not trigger a redraw.
    if (pChildElement->pParent != pParentElement) {
        drgui_detach(pChildElement);
    } else {
        drgui_detach_without_redraw(pChildElement);
    }


    // Now we attach it to the end of the new parent.
    if (pParentElement != NULL) {
        drgui_append_without_detach(pChildElement, pParentElement);
    }
}

void drgui_prepend(drgui_element* pChildElement, drgui_element* pParentElement)
{
    if (pChildElement == NULL) {
        return;
    }

    // See comment in drgui_append() for explanation on this.
    if (pChildElement->pParent != pParentElement) {
        drgui_detach(pChildElement);
    } else {
        drgui_detach_without_redraw(pChildElement);
    }


    // Now we need to attach the element to the beginning of the parent.
    if (pParentElement != NULL) {
        drgui_prepend_without_detach(pChildElement, pParentElement);
    }
}

void drgui_append_sibling(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo)
{
    if (pElementToAppend == NULL || pElementToAppendTo == NULL) {
        return;
    }

    // See comment in drgui_append() for explanation on this.
    if (pElementToAppend->pParent != pElementToAppendTo->pParent) {
        drgui_detach(pElementToAppend);
    } else {
        drgui_detach_without_redraw(pElementToAppend);
    }


    // Now we need to attach the element such that it comes just after pElementToAppendTo
    drgui_append_sibling_without_detach(pElementToAppend, pElementToAppendTo);
}

void drgui_prepend_sibling(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo)
{
    if (pElementToPrepend == NULL || pElementToPrependTo == NULL) {
        return;
    }

    // See comment in drgui_append() for explanation on this.
    if (pElementToPrepend->pParent != pElementToPrependTo->pParent) {
        drgui_detach(pElementToPrepend);
    } else {
        drgui_detach_without_redraw(pElementToPrepend);
    }


    // Now we need to attach the element such that it comes just after pElementToPrependTo
    drgui_prepend_sibling_without_detach(pElementToPrepend, pElementToPrependTo);
}

drgui_element* drgui_find_top_level_element(drgui_element* pElement)
{
    if (pElement == NULL) {
        return NULL;
    }

    if (pElement->pParent != NULL) {
        return drgui_find_top_level_element(pElement->pParent);
    }

    return pElement;
}

bool drgui_is_parent(drgui_element* pParentElement, drgui_element* pChildElement)
{
    if (pParentElement == NULL || pChildElement == NULL) {
        return false;
    }

    return pParentElement == pChildElement->pParent;
}

bool drgui_is_child(drgui_element* pChildElement, drgui_element* pParentElement)
{
    return drgui_is_parent(pParentElement, pChildElement);
}

bool drgui_is_ancestor(drgui_element* pAncestorElement, drgui_element* pChildElement)
{
    if (pAncestorElement == NULL || pChildElement == NULL) {
        return false;
    }

    drgui_element* pParent = pChildElement->pParent;
    while (pParent != NULL)
    {
        if (pParent == pAncestorElement) {
            return true;
        }

        pParent = pParent->pParent;
    }


    return false;
}

bool drgui_is_descendant(drgui_element* pChildElement, drgui_element* pAncestorElement)
{
    return drgui_is_ancestor(pAncestorElement, pChildElement);
}



//// Layout ////

void drgui_set_absolute_position(drgui_element* pElement, float positionX, float positionY)
{
    if (pElement != NULL)
    {
        if (pElement->absolutePosX != positionX || pElement->absolutePosY != positionY)
        {
            float oldRelativePosX = drgui_get_relative_position_x(pElement);
            float oldRelativePosY = drgui_get_relative_position_y(pElement);

            drgui_begin_auto_dirty(pElement, drgui_get_local_rect(pElement));   // <-- Previous rectangle.
            {
                float offsetX = positionX - pElement->absolutePosX;
                float offsetY = positionY - pElement->absolutePosY;

                pElement->absolutePosX = positionX;
                pElement->absolutePosY = positionY;
                drgui_auto_dirty(pElement, drgui_get_local_rect(pElement));     // <-- New rectangle.


                float newRelativePosX = drgui_get_relative_position_x(pElement);
                float newRelativePosY = drgui_get_relative_position_y(pElement);

                if (newRelativePosX != oldRelativePosX || newRelativePosY != oldRelativePosY) {
                    drgui_post_outbound_event_move(pElement, newRelativePosX, newRelativePosY);
                }


                drgui_apply_offset_to_children_recursive(pElement, offsetX, offsetY);
            }
            drgui_end_auto_dirty(pElement);
        }
    }
}

void drgui_get_absolute_position(const drgui_element* pElement, float * positionXOut, float * positionYOut)
{
    if (pElement != NULL)
    {
        if (positionXOut != NULL) {
            *positionXOut = pElement->absolutePosX;
        }

        if (positionYOut != NULL) {
            *positionYOut = pElement->absolutePosY;
        }
    }
}

float drgui_get_absolute_position_x(const drgui_element* pElement)
{
    if (pElement != NULL) {
        return pElement->absolutePosX;
    }

    return 0.0f;
}

float drgui_get_absolute_position_y(const drgui_element* pElement)
{
    if (pElement != NULL) {
        return pElement->absolutePosY;
    }

    return 0.0f;
}


void drgui_set_relative_position(drgui_element* pElement, float relativePosX, float relativePosY)
{
    if (pElement != NULL) {
        if (pElement->pParent != NULL)
        {
            drgui_set_absolute_position(pElement, pElement->pParent->absolutePosX + relativePosX, pElement->pParent->absolutePosY + relativePosY);
        }
        else
        {
            drgui_set_absolute_position(pElement, relativePosX, relativePosY);
        }
    }
}

void drgui_get_relative_position(const drgui_element* pElement, float* positionXOut, float* positionYOut)
{
    if (pElement != NULL)
    {
        if (pElement->pParent != NULL)
        {
            if (positionXOut != NULL) {
                *positionXOut = pElement->absolutePosX - pElement->pParent->absolutePosX;
            }

            if (positionYOut != NULL) {
                *positionYOut = pElement->absolutePosY - pElement->pParent->absolutePosY;
            }
        }
        else
        {
            if (positionXOut != NULL) {
                *positionXOut = pElement->absolutePosX;
            }

            if (positionYOut != NULL) {
                *positionYOut = pElement->absolutePosY;
            }
        }
    }
}

float drgui_get_relative_position_x(const drgui_element* pElement)
{
    if (pElement != NULL) {
        if (pElement->pParent != NULL) {
            return pElement->absolutePosX - pElement->pParent->absolutePosX;
        } else {
            return pElement->absolutePosX;
        }
    }

    return 0;
}

float drgui_get_relative_position_y(const drgui_element* pElement)
{
    if (pElement != NULL) {
        if (pElement->pParent != NULL) {
            return pElement->absolutePosY - pElement->pParent->absolutePosY;
        } else {
            return pElement->absolutePosY;
        }
    }

    return 0;
}


void drgui_set_size(drgui_element* pElement, float width, float height)
{
    if (pElement != NULL)
    {
        if (pElement->width != width || pElement->height != height)
        {
            drgui_begin_auto_dirty(pElement, drgui_get_local_rect(pElement));   // <-- Previous rectangle.
            {
                pElement->width  = width;
                pElement->height = height;
                drgui_auto_dirty(pElement, drgui_get_local_rect(pElement));     // <-- New rectangle.

                drgui_post_outbound_event_size(pElement, width, height);
            }
            drgui_end_auto_dirty(pElement);
        }
    }
}

void drgui_get_size(const drgui_element* pElement, float* widthOut, float* heightOut)
{
    if (pElement != NULL) {
        if (widthOut != NULL) {
            *widthOut = pElement->width;
        }

        if (heightOut != NULL) {
            *heightOut = pElement->height;
        }
    }
}

float drgui_get_width(const drgui_element * pElement)
{
    if (pElement != NULL) {
        return pElement->width;
    }

    return 0;
}

float drgui_get_height(const drgui_element * pElement)
{
    if (pElement != NULL) {
        return pElement->height;
    }

    return 0;
}


void drgui_set_inner_scale(drgui_element* pElement, float innerScaleX, float innerScaleY)
{
    if (pElement == NULL){
        return;
    }

    pElement->innerScaleX = innerScaleX;
    pElement->innerScaleY = innerScaleY;

    if (drgui_is_auto_dirty_enabled(pElement->pContext)) {
        drgui_dirty(pElement, drgui_get_local_rect(pElement));
    }
}

void drgui_get_inner_scale(drgui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut)
{
    float innerScaleX = 1;
    float innerScaleY = 1;

    if (pElement != NULL)
    {
        innerScaleX = pElement->innerScaleX;
        innerScaleY = pElement->innerScaleY;
    }


    if (pInnerScaleXOut) {
        *pInnerScaleXOut = innerScaleX;
    }
    if (pInnerScaleYOut) {
        *pInnerScaleYOut = innerScaleY;
    }
}

void drgui_get_absolute_inner_scale(drgui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut)
{
    float innerScaleX = 1;
    float innerScaleY = 1;

    if (pElement != NULL)
    {
        innerScaleX = pElement->innerScaleX;
        innerScaleY = pElement->innerScaleY;

        if (pElement->pParent != NULL)
        {
            float parentInnerScaleX;
            float parentInnerScaleY;
            drgui_get_absolute_inner_scale(pElement->pParent, &parentInnerScaleX, &parentInnerScaleY);

            innerScaleX *= parentInnerScaleX;
            innerScaleY *= parentInnerScaleY;
        }
    }

    if (pInnerScaleXOut) {
        *pInnerScaleXOut = innerScaleX;
    }
    if (pInnerScaleYOut) {
        *pInnerScaleYOut = innerScaleY;
    }
}


drgui_rect drgui_get_absolute_rect(const drgui_element* pElement)
{
    drgui_rect rect;
    if (pElement != NULL)
    {
        rect.left   = pElement->absolutePosX;
        rect.top    = pElement->absolutePosY;
        rect.right  = rect.left + pElement->width;
        rect.bottom = rect.top + pElement->height;
    }
    else
    {
        rect.left   = 0;
        rect.top    = 0;
        rect.right  = 0;
        rect.bottom = 0;
    }

    return rect;
}

drgui_rect drgui_get_relative_rect(const drgui_element* pElement)
{
    drgui_rect rect;
    if (pElement != NULL)
    {
        rect.left   = drgui_get_relative_position_x(pElement);
        rect.top    = drgui_get_relative_position_y(pElement);
        rect.right  = rect.left + pElement->width;
        rect.bottom = rect.top  + pElement->height;
    }
    else
    {
        rect.left   = 0;
        rect.top    = 0;
        rect.right  = 0;
        rect.bottom = 0;
    }

    return rect;
}

drgui_rect drgui_get_local_rect(const drgui_element* pElement)
{
    drgui_rect rect;
    rect.left = 0;
    rect.top  = 0;

    if (pElement != NULL)
    {
        rect.right  = pElement->width;
        rect.bottom = pElement->height;
    }
    else
    {
        rect.right  = 0;
        rect.bottom = 0;
    }

    return rect;
}



//// Painting ////

bool drgui_register_painting_callbacks(drgui_context* pContext, void* pPaintingContext, drgui_painting_callbacks callbacks)
{
    if (pContext == NULL) {
        return false;
    }

    // Fail if the painting callbacks have already been registered.
    if (pContext->pPaintingContext != NULL) {
        return false;
    }


    pContext->pPaintingContext  = pPaintingContext;
    pContext->paintingCallbacks = callbacks;

    return true;
}


bool drgui_iterate_visible_elements(drgui_element* pParentElement, drgui_rect relativeRect, drgui_visible_iteration_proc callback, void* pUserData)
{
    if (pParentElement == NULL) {
        return false;
    }

    if (callback == NULL) {
        return false;
    }


    if (!drgui_is_visible(pParentElement)) {
        return true;
    }

    drgui_rect clampedRelativeRect = relativeRect;
    if (drgui_clamp_rect_to_element(pParentElement, &clampedRelativeRect))
    {
        // We'll only get here if some part of the rectangle was inside the element.
        if (!callback(pParentElement, &clampedRelativeRect, pUserData)) {
            return false;
        }
    }

    for (drgui_element* pChild = pParentElement->pFirstChild; pChild != NULL; pChild = pChild->pNextSibling)
    {
        float childRelativePosX = drgui_get_relative_position_x(pChild);
        float childRelativePosY = drgui_get_relative_position_y(pChild);

        drgui_rect childRect;
        if (drgui_is_clipping_enabled(pChild)) {
            childRect = clampedRelativeRect;
        } else {
            childRect = relativeRect;
        }


        childRect.left   -= childRelativePosX;
        childRect.top    -= childRelativePosY;
        childRect.right  -= childRelativePosX;
        childRect.bottom -= childRelativePosY;

        if (!drgui_iterate_visible_elements(pChild, childRect, callback, pUserData)) {
            return false;
        }
    }


    return true;
}

void drgui_disable_auto_dirty(drgui_context* pContext)
{
    if (pContext != NULL) {
        pContext->flags |= IS_AUTO_DIRTY_DISABLED;
    }
}

void drgui_enable_auto_dirty(drgui_context* pContext)
{
    if (pContext != NULL) {
        pContext->flags &= ~IS_AUTO_DIRTY_DISABLED;
    }
}

bool drgui_is_auto_dirty_enabled(drgui_context* pContext)
{
    if (pContext != NULL) {
        return (pContext->flags & IS_AUTO_DIRTY_DISABLED) == 0;
    }

    return false;
}


void drgui_dirty(drgui_element* pElement, drgui_rect relativeRect)
{
    if (pElement == NULL) {
        return;
    }

    drgui_post_outbound_event_dirty_global(pElement, relativeRect);
}


bool drgui_draw_iteration_callback(drgui_element* pElement, drgui_rect* pRelativeRect, void* pUserData)
{
    assert(pElement      != NULL);
    assert(pRelativeRect != NULL);

    if (pElement->onPaint != NULL)
    {
        // We want to set the initial clipping rectangle before drawing.
        drgui_set_clip(pElement, *pRelativeRect, pUserData);

        // We now call the painting function, but only after setting the clipping rectangle.
        pElement->onPaint(pElement, *pRelativeRect, pUserData);

        // The on_paint event handler may have adjusted the clipping rectangle so we need to ensure it's restored.
        drgui_set_clip(pElement, *pRelativeRect, pUserData);
    }

    return true;
}

void drgui_draw(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    drgui_context* pContext = pElement->pContext;
    if (pContext == NULL) {
        return;
    }

    assert(pContext->paintingCallbacks.drawBegin != NULL);
    assert(pContext->paintingCallbacks.drawEnd   != NULL);

    pContext->paintingCallbacks.drawBegin(pPaintData);
    {
        drgui_iterate_visible_elements(pElement, relativeRect, drgui_draw_iteration_callback, pPaintData);
    }
    pContext->paintingCallbacks.drawEnd(pPaintData);
}

void drgui_get_clip(drgui_element* pElement, drgui_rect* pRelativeRect, void* pPaintData)
{
    if (pElement == NULL || pElement->pContext == NULL) {
        return;
    }

    pElement->pContext->paintingCallbacks.getClip(pRelativeRect, pPaintData);

    if (pRelativeRect)
    {
        float scaleX;
        float scaleY;
        drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

        pRelativeRect->left   /= scaleX;
        pRelativeRect->top    /= scaleY;
        pRelativeRect->right  /= scaleX;
        pRelativeRect->bottom /= scaleY;
    }

    // The clip returned by the drawing callback will be absolute so we'll need to convert that to relative.
    drgui_make_rect_relative(pElement, pRelativeRect);
}

void drgui_set_clip(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData)
{
    if (pElement == NULL || pElement->pContext == NULL) {
        return;
    }


    // Make sure the rectangle is not negative.
    if (relativeRect.right < relativeRect.left) {
        relativeRect.right = relativeRect.left;
    }

    if (relativeRect.bottom < relativeRect.top) {
        relativeRect.bottom = relativeRect.top;
    }

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    pElement->pContext->paintingCallbacks.setClip(absoluteRect, pPaintData);
}

void drgui_draw_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    pElement->pContext->paintingCallbacks.drawRect(absoluteRect, color, pPaintData);
}

void drgui_draw_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    if (scaleX == scaleY)
    {
        pElement->pContext->paintingCallbacks.drawRectOutline(absoluteRect, color, (outlineWidth * scaleX), pPaintData);
    }
    else
    {
        // TODO: This is incorrect. The left and right borders need to be scaled by scaleX and the top and bottom borders need to be scaled by scaleY.
        pElement->pContext->paintingCallbacks.drawRectOutline(absoluteRect, color, (outlineWidth * scaleX), pPaintData);
    }
}

void drgui_draw_rect_with_outline(drgui_element * pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, drgui_color outlineColor, void * pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    if (scaleX == scaleY)
    {
        pElement->pContext->paintingCallbacks.drawRectWithOutline(absoluteRect, color, (outlineWidth * scaleX), outlineColor, pPaintData);
    }
    else
    {
        // TODO: This is incorrect. The left and right borders need to be scaled by scaleX and the top and bottom borders need to be scaled by scaleY.
        pElement->pContext->paintingCallbacks.drawRectWithOutline(absoluteRect, color, (outlineWidth * scaleX), outlineColor, pPaintData);
    }
}

void drgui_draw_round_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    if (scaleX == scaleY)
    {
        pElement->pContext->paintingCallbacks.drawRoundRect(absoluteRect, color, (radius * scaleX), pPaintData);
    }
    else
    {
        // TODO: The corners need to be rounded based on an ellipse rather than a circle.
        pElement->pContext->paintingCallbacks.drawRoundRect(absoluteRect, color, (radius * scaleX), pPaintData);
    }
}

void drgui_draw_round_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    if (scaleX == scaleY)
    {
        pElement->pContext->paintingCallbacks.drawRoundRectOutline(absoluteRect, color, (radius * scaleX), floorf(outlineWidth * scaleX), pPaintData);
    }
    else
    {
        // TODO: This is incorrect. The left and right borders need to be scaled by scaleX and the top and bottom borders need to be scaled by scaleY. The corners need to be rounded based on an ellipse rather than a circle.
        pElement->pContext->paintingCallbacks.drawRoundRectOutline(absoluteRect, color, (radius * scaleX), (outlineWidth * scaleX), pPaintData);
    }
}

void drgui_draw_round_rect_with_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData)
{
    if (pElement == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_rect absoluteRect = relativeRect;
    drgui_make_rect_absolute(pElement, &absoluteRect);
    absoluteRect = drgui_scale_rect(absoluteRect, scaleX, scaleY);

    if (scaleX == scaleY)
    {
        pElement->pContext->paintingCallbacks.drawRoundRectWithOutline(absoluteRect, color, (radius * scaleX), (outlineWidth * scaleX), outlineColor, pPaintData);
    }
    else
    {
        // TODO: This is incorrect. The left and right borders need to be scaled by scaleX and the top and bottom borders need to be scaled by scaleY. The corners need to be rounded based on an ellipse rather than a circle.
        pElement->pContext->paintingCallbacks.drawRoundRectWithOutline(absoluteRect, color, (radius * scaleX), (outlineWidth * scaleX), outlineColor, pPaintData);
    }
}

void drgui_draw_text(drgui_element* pElement, drgui_font* pFont, const char* text, int textLengthInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData)
{
    if (pElement == NULL || pFont == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    float absolutePosX = posX * scaleX;
    float absolutePosY = posY * scaleX;
    drgui_make_point_absolute(pElement, &absolutePosX, &absolutePosY);

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return;
    }

    pElement->pContext->paintingCallbacks.drawText(font, text, textLengthInBytes, absolutePosX, absolutePosY, color, backgroundColor, pPaintData);
}

void drgui_draw_image(drgui_element* pElement, drgui_image* pImage, drgui_draw_image_args* pArgs, void* pPaintData)
{
    if (pElement == NULL || pImage == NULL) {
        return;
    }

    assert(pElement->pContext != NULL);

    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    drgui_make_point_absolute(pElement, &pArgs->dstX, &pArgs->dstY);
    drgui_make_point_absolute(pElement, &pArgs->dstBoundsX, &pArgs->dstBoundsY);

    pArgs->dstX            *= scaleX;
    pArgs->dstY            *= scaleY;
    pArgs->dstWidth        *= scaleX;
    pArgs->dstHeight       *= scaleY;
    pArgs->dstBoundsX      *= scaleX;
    pArgs->dstBoundsY      *= scaleY;
    pArgs->dstBoundsWidth  *= scaleX;
    pArgs->dstBoundsHeight *= scaleY;


    pElement->pContext->paintingCallbacks.drawImage(pImage->hResource, pArgs, pPaintData);
}


drgui_font* drgui_create_font(drgui_context* pContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation)
{
    if (pContext == NULL) {
        return NULL;
    }

    if (pContext->paintingCallbacks.createFont == NULL) {
        return NULL;
    }


    drgui_resource internalFont = pContext->paintingCallbacks.createFont(pContext->pPaintingContext, family, size, weight, slant, rotation);
    if (internalFont == NULL) {
        return NULL;
    }

    drgui_font* pFont = malloc(sizeof(drgui_font));
    if (pFont == NULL) {
        return NULL;
    }

    pFont->pContext          = pContext;
    pFont->family[0]         = '\0';
    pFont->size              = size;
    pFont->weight            = weight;
    pFont->slant             = slant;
    pFont->rotation          = rotation;
    pFont->internalFontCount = 1;
    pFont->pInternalFonts    = malloc(sizeof(drgui_resource) * pFont->internalFontCount);
    pFont->pInternalFonts[0] = internalFont;

    if (family != NULL) {
        drgui__strcpy_s(pFont->family, sizeof(pFont->family), family);
    }

    return pFont;
}

void drgui_delete_font(drgui_font* pFont)
{
    if (pFont == NULL) {
        return;
    }

    assert(pFont->pContext != NULL);

    // Delete the internal font objects first.
    if (pFont->pContext->paintingCallbacks.deleteFont) {
        for (size_t i = 0; i < pFont->internalFontCount; ++i) {
            pFont->pContext->paintingCallbacks.deleteFont(pFont->pInternalFonts[i]);
        }
    }

    free(pFont->pInternalFonts);
    free(pFont);
}

bool drgui_get_font_metrics(drgui_font* pFont, float scaleX, float scaleY, drgui_font_metrics* pMetricsOut)
{
    (void)scaleX;

    if (pFont == NULL || pMetricsOut == NULL) {
        return false;
    }

    assert(pFont->pContext != NULL);

    if (pFont->pContext->paintingCallbacks.getFontMetrics == NULL) {
        return false;
    }

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return false;
    }

    bool result = pFont->pContext->paintingCallbacks.getFontMetrics(font, pMetricsOut);
    if (result)
    {
        if (pMetricsOut != NULL)
        {
            pMetricsOut->ascent     = (unsigned int)(pMetricsOut->ascent     / scaleY);
            pMetricsOut->descent    = (unsigned int)(pMetricsOut->descent    / scaleY);
            pMetricsOut->lineHeight = (unsigned int)(pMetricsOut->lineHeight / scaleY);
            pMetricsOut->spaceWidth = (unsigned int)(pMetricsOut->spaceWidth / scaleX);
        }
    }

    return result;
}

bool drgui_get_font_metrics_by_element(drgui_font* pFont, drgui_element* pElement, drgui_font_metrics* pMetricsOut)
{
    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    return drgui_get_font_metrics(pFont, scaleX, scaleY, pMetricsOut);
}

bool drgui_get_glyph_metrics(drgui_font* pFont, unsigned int utf32, float scaleX, float scaleY, drgui_glyph_metrics* pMetricsOut)
{
    (void)scaleY;

    if (pFont == NULL || pMetricsOut == NULL) {
        return false;
    }

    assert(pFont->pContext != NULL);

    if (pFont->pContext->paintingCallbacks.getGlyphMetrics == NULL) {
        return false;
    }

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return false;
    }

    bool result = pFont->pContext->paintingCallbacks.getGlyphMetrics(font, utf32, pMetricsOut);
    if (result)
    {
        if (pMetricsOut != NULL)
        {
            pMetricsOut->width    = (unsigned int)(pMetricsOut->width    / scaleX);
            pMetricsOut->height   = (unsigned int)(pMetricsOut->height   / scaleY);
            pMetricsOut->originX  = (unsigned int)(pMetricsOut->originX  / scaleX);
            pMetricsOut->originY  = (unsigned int)(pMetricsOut->originY  / scaleY);
            pMetricsOut->advanceX = (unsigned int)(pMetricsOut->advanceX / scaleX);
            pMetricsOut->advanceY = (unsigned int)(pMetricsOut->advanceY / scaleY);
        }
    }

    return result;
}

bool drgui_get_glyph_metrics_by_element(drgui_font* pFont, unsigned int utf32, drgui_element* pElement, drgui_glyph_metrics* pMetricsOut)
{
    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    return drgui_get_glyph_metrics(pFont, utf32, scaleX, scaleY, pMetricsOut);
}

bool drgui_measure_string(drgui_font* pFont, const char* text, size_t textLengthInBytes, float scaleX, float scaleY, float* pWidthOut, float* pHeightOut)
{
    if (pFont == NULL) {
        return false;
    }

    if (text == NULL || textLengthInBytes == 0)
    {
        drgui_font_metrics metrics;
        if (!drgui_get_font_metrics(pFont, scaleX, scaleY, &metrics)) {
            return false;
        }

        if (pWidthOut) {
            *pWidthOut = 0;
        }
        if (pHeightOut) {
            *pHeightOut = (float)metrics.lineHeight;
        }

        return true;
    }



    assert(pFont->pContext != NULL);

    if (pFont->pContext->paintingCallbacks.measureString == NULL) {
        return false;
    }

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return false;
    }

    bool result = pFont->pContext->paintingCallbacks.measureString(font, text, textLengthInBytes, pWidthOut, pHeightOut);
    if (result)
    {
        if (pWidthOut) {
            *pWidthOut = (*pWidthOut / scaleX);
        }
        if (pHeightOut) {
            *pHeightOut = (*pHeightOut / scaleY);
        }
    }

    return result;
}

bool drgui_measure_string_by_element(drgui_font* pFont, const char* text, size_t textLengthInBytes, drgui_element* pElement, float* pWidthOut, float* pHeightOut)
{
    float scaleX;
    float scaleY;
    drgui_get_absolute_inner_scale(pElement, &scaleX, &scaleY);

    return drgui_measure_string(pFont, text, textLengthInBytes, scaleX, scaleY, pWidthOut, pHeightOut);
}

bool drgui_get_text_cursor_position_from_point(drgui_font* pFont, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float scaleX, float scaleY, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut)
{
    (void)scaleX;

    if (pFont == NULL) {
        return false;
    }

    assert(pFont->pContext != NULL);

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return false;
    }

    if (pFont->pContext->paintingCallbacks.getTextCursorPositionFromPoint) {
        return pFont->pContext->paintingCallbacks.getTextCursorPositionFromPoint(font, text, textSizeInBytes, maxWidth, inputPosX, pTextCursorPosXOut, pCharacterIndexOut);
    }

    return false;
}

bool drgui_get_text_cursor_position_from_char(drgui_font* pFont, const char* text, unsigned int characterIndex, float scaleX, float scaleY, float* pTextCursorPosXOut)
{
    (void)scaleX;

    if (pFont == NULL) {
        return false;
    }

    assert(pFont->pContext != NULL);

    drgui_resource font = drgui_get_internal_font_by_scale(pFont, scaleY);
    if (font == NULL) {
        return false;
    }

    if (pFont->pContext->paintingCallbacks.getTextCursorPositionFromChar) {
        return pFont->pContext->paintingCallbacks.getTextCursorPositionFromChar(font, text, characterIndex, pTextCursorPosXOut);
    }

    return false;
}



drgui_image* drgui_create_image(drgui_context* pContext, unsigned int width, unsigned int height, unsigned int stride, const void* pData)
{
    if (pContext == NULL) {
        return NULL;
    }

    if (pContext->paintingCallbacks.createImage == NULL) {
        return NULL;
    }


    drgui_resource internalImage = pContext->paintingCallbacks.createImage(pContext->pPaintingContext, width, height, stride, pData);
    if (internalImage == NULL) {
        return NULL;
    }

    drgui_image* pImage = malloc(sizeof(*pImage));
    if (pImage == NULL) {
        return NULL;
    }

    pImage->pContext  = pContext;
    pImage->hResource = internalImage;


    return pImage;
}

void drgui_delete_image(drgui_image* pImage)
{
    if (pImage == NULL) {
        return;
    }

    assert(pImage->pContext != NULL);

    // Delete the internal font object.
    if (pImage->pContext->paintingCallbacks.deleteImage) {
        pImage->pContext->paintingCallbacks.deleteImage(pImage->hResource);
    }

    // Free the font object last.
    free(pImage);
}

void drgui_get_image_size(drgui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut)
{
    if (pImage == NULL) {
        return;
    }

    assert(pImage->pContext != NULL);

    if (pImage->pContext->paintingCallbacks.getImageSize == NULL) {
        return;
    }

    pImage->pContext->paintingCallbacks.getImageSize(pImage->hResource, pWidthOut, pHeightOut);
}



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

void drgui_on_size_fit_children_to_parent(drgui_element* pElement, float newWidth, float newHeight)
{
    float scaleX;
    float scaleY;
    drgui_get_inner_scale(pElement, &scaleX, &scaleY);

    for (drgui_element* pChild = pElement->pFirstChild; pChild != NULL; pChild = pChild->pNextSibling)
    {
        drgui_set_size(pChild, newWidth / scaleX, newHeight / scaleY);
    }
}

bool drgui_pass_through_hit_test(drgui_element* pElement, float mousePosX, float mousePosY)
{
    (void)pElement;
    (void)mousePosX;
    (void)mousePosY;

    return false;
}



//// Painting ////

void drgui_draw_border(drgui_element* pElement, float borderWidth, drgui_color color, void* pUserData)
{
    drgui_draw_rect_outline(pElement, drgui_get_local_rect(pElement), color, borderWidth, pUserData);
}



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

drgui_color drgui_rgba(drgui_byte r, drgui_byte g, drgui_byte b, drgui_byte a)
{
    drgui_color color;
    color.r = r;
    color.g = g;
    color.b = b;
    color.a = a;

    return color;
}

drgui_color drgui_rgb(drgui_byte r, drgui_byte g, drgui_byte b)
{
    drgui_color color;
    color.r = r;
    color.g = g;
    color.b = b;
    color.a = 255;

    return color;
}

drgui_rect drgui_clamp_rect(drgui_rect rect, drgui_rect other)
{
    drgui_rect result;
    result.left   = (rect.left   >= other.left)   ? rect.left   : other.left;
    result.top    = (rect.top    >= other.top)    ? rect.top    : other.top;
    result.right  = (rect.right  <= other.right)  ? rect.right  : other.right;
    result.bottom = (rect.bottom <= other.bottom) ? rect.bottom : other.bottom;

    return result;
}

bool drgui_clamp_rect_to_element(const drgui_element* pElement, drgui_rect* pRelativeRect)
{
    if (pElement == NULL || pRelativeRect == NULL) {
        return false;
    }


    if (pRelativeRect->left < 0) {
        pRelativeRect->left = 0;
    }
    if (pRelativeRect->top < 0) {
        pRelativeRect->top = 0;
    }

    if (pRelativeRect->right > pElement->width) {
        pRelativeRect->right = pElement->width;
    }
    if (pRelativeRect->bottom > pElement->height) {
        pRelativeRect->bottom = pElement->height;
    }


    return (pRelativeRect->right - pRelativeRect->left > 0) && (pRelativeRect->bottom - pRelativeRect->top > 0);
}

drgui_rect drgui_make_rect_relative(const drgui_element* pElement, drgui_rect* pRect)
{
    if (pElement == NULL || pRect == NULL) {
        return drgui_make_rect(0, 0, 0, 0);
    }

    pRect->left   -= pElement->absolutePosX;
    pRect->top    -= pElement->absolutePosY;
    pRect->right  -= pElement->absolutePosX;
    pRect->bottom -= pElement->absolutePosY;

    return *pRect;
}

drgui_rect drgui_make_rect_absolute(const drgui_element * pElement, drgui_rect * pRect)
{
    if (pElement == NULL || pRect == NULL) {
        return drgui_make_rect(0, 0, 0, 0);
    }

    pRect->left   += pElement->absolutePosX;
    pRect->top    += pElement->absolutePosY;
    pRect->right  += pElement->absolutePosX;
    pRect->bottom += pElement->absolutePosY;

    return *pRect;
}

void drgui_make_point_relative(const drgui_element* pElement, float* positionX, float* positionY)
{
    if (pElement != NULL)
    {
        if (positionX != NULL) {
            *positionX -= pElement->absolutePosX;
        }

        if (positionY != NULL) {
            *positionY -= pElement->absolutePosY;
        }
    }
}

void drgui_make_point_absolute(const drgui_element* pElement, float* positionX, float* positionY)
{
    if (pElement != NULL)
    {
        if (positionX != NULL) {
            *positionX += pElement->absolutePosX;
        }

        if (positionY != NULL) {
            *positionY += pElement->absolutePosY;
        }
    }
}

drgui_rect drgui_make_rect(float left, float top, float right, float bottom)
{
    drgui_rect rect;
    rect.left   = left;
    rect.top    = top;
    rect.right  = right;
    rect.bottom = bottom;

    return rect;
}

drgui_rect drgui_make_inside_out_rect()
{
    drgui_rect rect;
    rect.left   =  FLT_MAX;
    rect.top    =  FLT_MAX;
    rect.right  = -FLT_MAX;
    rect.bottom = -FLT_MAX;

    return rect;
}

drgui_rect drgui_grow_rect(drgui_rect rect, float amount)
{
    drgui_rect result = rect;
    result.left   -= amount;
    result.top    -= amount;
    result.right  += amount;
    result.bottom += amount;

    return result;
}

drgui_rect drgui_scale_rect(drgui_rect rect, float scaleX, float scaleY)
{
    drgui_rect result = rect;
    result.left   *= scaleX;
    result.top    *= scaleY;
    result.right  *= scaleX;
    result.bottom *= scaleY;

    return result;
}

drgui_rect drgui_offset_rect(drgui_rect rect, float offsetX, float offsetY)
{
    return drgui_make_rect(rect.left + offsetX, rect.top + offsetY, rect.right + offsetX, rect.bottom + offsetY);
}

drgui_rect drgui_rect_union(drgui_rect rect0, drgui_rect rect1)
{
    drgui_rect result;
    result.left   = (rect0.left   < rect1.left)   ? rect0.left   : rect1.left;
    result.top    = (rect0.top    < rect1.top)    ? rect0.top    : rect1.top;
    result.right  = (rect0.right  > rect1.right)  ? rect0.right  : rect1.right;
    result.bottom = (rect0.bottom > rect1.bottom) ? rect0.bottom : rect1.bottom;

    return result;
}

bool drgui_rect_contains_point(drgui_rect rect, float posX, float posY)
{
    if (posX < rect.left || posY < rect.top) {
        return false;
    }

    if (posX >= rect.right || posY >= rect.bottom) {
        return false;
    }

    return true;
}

bool drgui_rect_equal(drgui_rect rect0, drgui_rect rect1)
{
    return
        rect0.left   == rect1.left  &&
        rect0.top    == rect1.top   &&
        rect0.right  == rect1.right &&
        rect0.bottom == rect1.bottom;
}




/////////////////////////////////////////////////////////////////
//
// EASY_DRAW-SPECIFIC API
//
/////////////////////////////////////////////////////////////////
#ifndef DRGUI_NO_DR_2D

void drgui_draw_begin_dr_2d(void* pPaintData);
void drgui_draw_end_dr_2d(void* pPaintData);
void drgui_set_clip_dr_2d(drgui_rect rect, void* pPaintData);
void drgui_get_clip_dr_2d(drgui_rect* pRectOut, void* pPaintData);
void drgui_draw_rect_dr_2d(drgui_rect rect, drgui_color color, void* pPaintData);
void drgui_draw_rect_outline_dr_2d(drgui_rect, drgui_color, float, void*);
void drgui_draw_rect_with_outline_dr_2d(drgui_rect, drgui_color, float, drgui_color, void*);
void drgui_draw_round_rect_dr_2d(drgui_rect, drgui_color, float, void*);
void drgui_draw_round_rect_outline_dr_2d(drgui_rect, drgui_color, float, float, void*);
void drgui_draw_round_rect_with_outline_dr_2d(drgui_rect, drgui_color, float, float, drgui_color, void*);
void drgui_draw_text_dr_2d(drgui_resource, const char*, int, float, float, drgui_color, drgui_color, void*);
void drgui_draw_image_dr_2d(drgui_resource image, drgui_draw_image_args* pArgs, void* pPaintData);

drgui_resource drgui_create_font_dr_2d(void*, const char*, unsigned int, drgui_font_weight, drgui_font_slant, float);
void drgui_delete_font_dr_2d(drgui_resource);
unsigned int drgui_get_font_size_dr_2d(drgui_resource hFont);
bool drgui_get_font_metrics_dr_2d(drgui_resource, drgui_font_metrics*);
bool drgui_get_glyph_metrics_dr_2d(drgui_resource, unsigned int, drgui_glyph_metrics*);
bool drgui_measure_string_dr_2d(drgui_resource, const char*, size_t, float*, float*);
bool drgui_get_text_cursor_position_from_point_dr_2d(drgui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut);
bool drgui_get_text_cursor_position_from_char_dr_2d(drgui_resource font, const char* text, unsigned int characterIndex, float* pTextCursorPosXOut);

drgui_resource drgui_create_image_dr_2d(void* pPaintingContext, unsigned int width, unsigned int height, unsigned int stride, const void* pImageData);
void drgui_delete_image_dr_2d(drgui_resource image);
void drgui_get_image_size_dr_2d(drgui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut);

drgui_context* drgui_create_context_dr_2d(dr2d_context* pDrawingContext)
{
    drgui_context* pContext = drgui_create_context();
    if (pContext != NULL) {
        drgui_register_dr_2d_callbacks(pContext, pDrawingContext);
    }

    return pContext;
}

void drgui_register_dr_2d_callbacks(drgui_context* pContext, dr2d_context* pDrawingContext)
{
    drgui_painting_callbacks callbacks;
    callbacks.drawBegin                      = drgui_draw_begin_dr_2d;
    callbacks.drawEnd                        = drgui_draw_end_dr_2d;
    callbacks.setClip                        = drgui_set_clip_dr_2d;
    callbacks.getClip                        = drgui_get_clip_dr_2d;
    callbacks.drawRect                       = drgui_draw_rect_dr_2d;
    callbacks.drawRectOutline                = drgui_draw_rect_outline_dr_2d;
    callbacks.drawRectWithOutline            = drgui_draw_rect_with_outline_dr_2d;
    callbacks.drawRoundRect                  = drgui_draw_round_rect_dr_2d;
    callbacks.drawRoundRectOutline           = drgui_draw_round_rect_outline_dr_2d;
    callbacks.drawRoundRectWithOutline       = drgui_draw_round_rect_with_outline_dr_2d;
    callbacks.drawText                       = drgui_draw_text_dr_2d;
    callbacks.drawImage                      = drgui_draw_image_dr_2d;

    callbacks.createFont                     = drgui_create_font_dr_2d;
    callbacks.deleteFont                     = drgui_delete_font_dr_2d;
    callbacks.getFontSize                    = drgui_get_font_size_dr_2d;
    callbacks.getFontMetrics                 = drgui_get_font_metrics_dr_2d;
    callbacks.getGlyphMetrics                = drgui_get_glyph_metrics_dr_2d;
    callbacks.measureString                  = drgui_measure_string_dr_2d;

    callbacks.createImage                    = drgui_create_image_dr_2d;
    callbacks.deleteImage                    = drgui_delete_image_dr_2d;
    callbacks.getImageSize                   = drgui_get_image_size_dr_2d;
    callbacks.getTextCursorPositionFromPoint = drgui_get_text_cursor_position_from_point_dr_2d;
    callbacks.getTextCursorPositionFromChar  = drgui_get_text_cursor_position_from_char_dr_2d;

    drgui_register_painting_callbacks(pContext, pDrawingContext, callbacks);
}


void drgui_draw_begin_dr_2d(void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_begin_draw(pSurface);
}

void drgui_draw_end_dr_2d(void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_end_draw(pSurface);
}

void drgui_set_clip_dr_2d(drgui_rect rect, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_set_clip(pSurface, rect.left, rect.top, rect.right, rect.bottom);
}

void drgui_get_clip_dr_2d(drgui_rect* pRectOut, void* pPaintData)
{
    assert(pRectOut != NULL);

    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_get_clip(pSurface, &pRectOut->left, &pRectOut->top, &pRectOut->right, &pRectOut->bottom);
}

void drgui_draw_rect_dr_2d(drgui_rect rect, drgui_color color, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_rect(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a));
}

void drgui_draw_rect_outline_dr_2d(drgui_rect rect, drgui_color color, float outlineWidth, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_rect_outline(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a), outlineWidth);
}

void drgui_draw_rect_with_outline_dr_2d(drgui_rect rect, drgui_color color, float outlineWidth, drgui_color outlineColor, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_rect_with_outline(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a), outlineWidth, dr2d_rgba(outlineColor.r, outlineColor.g, outlineColor.b, outlineColor.a));
}

void drgui_draw_round_rect_dr_2d(drgui_rect rect, drgui_color color, float radius, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_round_rect(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a), radius);
}

void drgui_draw_round_rect_outline_dr_2d(drgui_rect rect, drgui_color color, float radius, float outlineWidth, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_round_rect_outline(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a), radius, outlineWidth);
}

void drgui_draw_round_rect_with_outline_dr_2d(drgui_rect rect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_round_rect_with_outline(pSurface, rect.left, rect.top, rect.right, rect.bottom, dr2d_rgba(color.r, color.g, color.b, color.a), radius, outlineWidth, dr2d_rgba(outlineColor.r, outlineColor.g, outlineColor.b, outlineColor.a));
}

void drgui_draw_text_dr_2d(drgui_resource font, const char* text, int textSizeInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_text(pSurface, font, text, textSizeInBytes, posX, posY, dr2d_rgba(color.r, color.g, color.b, color.a), dr2d_rgba(backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a));
}

void drgui_draw_image_dr_2d(drgui_resource image, drgui_draw_image_args* pArgs, void* pPaintData)
{
    dr2d_surface* pSurface = (dr2d_surface*)pPaintData;
    assert(pSurface != NULL);

    dr2d_draw_image_args args;
    args.dstX            = pArgs->dstX;
    args.dstY            = pArgs->dstY;
    args.dstWidth        = pArgs->dstWidth;
    args.dstHeight       = pArgs->dstHeight;
    args.srcX            = pArgs->srcX;
    args.srcY            = pArgs->srcY;
    args.srcWidth        = pArgs->srcWidth;
    args.srcHeight       = pArgs->srcHeight;
    args.dstBoundsX      = pArgs->dstBoundsX;
    args.dstBoundsY      = pArgs->dstBoundsY;
    args.dstBoundsWidth  = pArgs->dstBoundsWidth;
    args.dstBoundsHeight = pArgs->dstBoundsHeight;
    args.foregroundTint  = dr2d_rgba(pArgs->foregroundTint.r, pArgs->foregroundTint.g, pArgs->foregroundTint.b, pArgs->foregroundTint.a);
    args.backgroundColor = dr2d_rgba(pArgs->backgroundColor.r, pArgs->backgroundColor.g, pArgs->backgroundColor.b, pArgs->backgroundColor.a);
    args.boundsColor     = dr2d_rgba(pArgs->boundsColor.r, pArgs->boundsColor.g, pArgs->boundsColor.b, pArgs->boundsColor.a);
    args.options         = pArgs->options;
    dr2d_draw_image(pSurface, image, &args);
}


drgui_resource drgui_create_font_dr_2d(void* pPaintingContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation)
{
    return dr2d_create_font(pPaintingContext, family, size, weight, slant, rotation);
}

void drgui_delete_font_dr_2d(drgui_resource font)
{
    dr2d_delete_font(font);
}

unsigned int drgui_get_font_size_dr_2d(drgui_resource font)
{
    return dr2d_get_font_size(font);
}

bool drgui_get_font_metrics_dr_2d(drgui_resource font, drgui_font_metrics* pMetricsOut)
{
    assert(pMetricsOut != NULL);

    dr2d_font_metrics metrics;
    if (!dr2d_get_font_metrics(font, &metrics)) {
        return false;
    }

    pMetricsOut->ascent     = metrics.ascent;
    pMetricsOut->descent    = metrics.descent;
    pMetricsOut->lineHeight = metrics.lineHeight;
    pMetricsOut->spaceWidth = metrics.spaceWidth;

    return true;
}

bool drgui_get_glyph_metrics_dr_2d(drgui_resource font, unsigned int utf32, drgui_glyph_metrics* pMetricsOut)
{
    assert(pMetricsOut != NULL);

    dr2d_glyph_metrics metrics;
    if (!dr2d_get_glyph_metrics(font, utf32, &metrics)) {
        return false;
    }

    pMetricsOut->width    = metrics.width;
    pMetricsOut->height   = metrics.height;
    pMetricsOut->originX  = metrics.originX;
    pMetricsOut->originY  = metrics.originY;
    pMetricsOut->advanceX = metrics.advanceX;
    pMetricsOut->advanceY = metrics.advanceY;

    return true;
}

bool drgui_measure_string_dr_2d(drgui_resource font, const char* text, size_t textSizeInBytes, float* pWidthOut, float* pHeightOut)
{
    return dr2d_measure_string(font, text, textSizeInBytes, pWidthOut, pHeightOut);
}

bool drgui_get_text_cursor_position_from_point_dr_2d(drgui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut)
{
    return dr2d_get_text_cursor_position_from_point(font, text, textSizeInBytes, maxWidth, inputPosX, pTextCursorPosXOut, pCharacterIndexOut);
}

bool drgui_get_text_cursor_position_from_char_dr_2d(drgui_resource font, const char* text, unsigned int characterIndex, float* pTextCursorPosXOut)
{
    return dr2d_get_text_cursor_position_from_char(font, text, characterIndex, pTextCursorPosXOut);
}


drgui_resource drgui_create_image_dr_2d(void* pPaintingContext, unsigned int width, unsigned int height, unsigned int stride, const void* pImageData)
{
    return dr2d_create_image(pPaintingContext, width, height, stride, pImageData);
}

void drgui_delete_image_dr_2d(drgui_resource image)
{
    dr2d_delete_image(image);
}

void drgui_get_image_size_dr_2d(drgui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut)
{
    dr2d_get_image_size(image, pWidthOut, pHeightOut);
}

#endif  //DRGUI_NO_DR_2D
#endif  //DR_GUI_IMPLEMENTATION

#ifdef DR_GUI_INCLUDE_WIP
#include "wip/dr_gui_text_layout.h"
#include "wip/dr_gui_scrollbar.h"
#include "wip/dr_gui_tab_bar.h"
#include "wip/dr_gui_textbox.h"
#include "wip/dr_gui_tree_view.h"
#endif  //DR_GUI_INCLUDE_WIP

/*
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/
